<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello 2020]]></title>
    <url>%2F2020%2F01%2F01%2Fhello-2020%2F</url>
    <content type="text"><![CDATA[学习简单来说：保持饥饿感，每天学一点，每周做小结，每月定计划细分起来，新年主要想学这么几块：1.Kotlin2.Java进阶&amp;并发3.Android SDK源码学习 读书还是按部就班通过kindle也好，纸质书也罢，坚持读书。另外有个支线任务，就是看一些经济学类的书籍，主要是《经济学基础》上下册，《博弈论》，《国富论》。 健身坚持健身，每月都报当月的健身课。当天有课就去上课，没课就自己做有氧。 理财理性消费，不用花呗、信用卡等借贷类产品，定投指数基金。 游戏没什么好计划的，随心所欲玩就完事儿了，当然也有几个特别想冲的《荒野大镖客》《死亡搁浅》《赛博朋克2077》其他随缘就好 。总而言之，2020的小目标就是：1.学自己想学的2.读足够多的书，并完成支线任务：经济学3.坚持健身，体重减到1604.理财，定个小目标，存够十五万5.开开心心玩游戏]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于编码]]></title>
    <url>%2F2019%2F10%2F03%2Fabout-encode%2F</url>
    <content type="text"><![CDATA[背景首先要知道，有一个最小单位为 位 ，也就是常说的 bit 。一个 bit ，值只能为1或0。一个字节，由八个位组成，即1 byte = 8 bit。因为一个字节由8个位组成，比如 1010 0101 ，所以显然一个字节能表示的最大的数就是8位全为1，即 1111 1111（二进制）。转为10进制，也就是255。想表示更大的数，就需要多个字节拼起来，比如两个字节拼起来的最大数为 1111 1111 1111 1111，对应的十进制是65535。计算机上要显示的文字内容，有很多，比如abcd，1234，+-*/等等，这些每一个字符，都是跟一个数字对应起来的，形成了一个字典，这个字典就是编码规则。 ASCII计算机是美国人发明的，那个时候，需要在计算机上显示的字符，内容构成很简单的，只包含了所有大小写字母，数字，和一些常用符号，总计有127个字符。这样的话字符只要用一个字节表示就够了。比如65对应A，z对应122。这个对应关系，便被称为 ASCII 编码。 GB2312等等后来，随着计算机的普及，世界各国的人都开始使用计算机了。中国人要在计算机上显示中文，日本人要在计算机上显示日文，诸如此类，世界上有很多语言的文字都需要显示，然而计算机当前只能显示127个基本字符，这显然是远远不够的。因此，各国开始搞自己的编码了。因为新的字符实在太多了，而一个字节显然不够，所以新的编码格式，比如中国的 GB2312 ，就是用至少两个字节来表示一个字符。类似的，日本人有自己的 Shift_JIS 编码，韩国人有 Euc-kr 。这时的编码就很乱了。 Unicode因为类似 GB2312 一样的各种编码互相冲突，所以又出现了一种新的编码方式 Unicode ，来将所有的编码统一处理，这样不管你用什么国家的语言，只要用我 Unicode ，那都可以显示出来。在 Unicode 编码中，一个字符通常由两个字节组成（除非一些非常偏僻的字符 会多一点）。 UTF-8虽然 Unicode 很通用，但是有一些冗余的情况。为什么呢？比如一个大写字母A，他之前在 ASCII 下对应65，二进制也就是0100 0001，在 Unicode 编码中，只要在前面补一个0字节即可，即他对应为0000 0000 0100 0001。这样问题来了，之前 ASCII 定义的这些字符在 Unicode 中，都在前面白白加了8个0，这样在传输时多浪费空间啊。所以，由 Unicode 演化出一种新的编码， UTF-8 。在 UTF-8 中，不同的字符对应的字节数也不同。常见的英文字母等 ASCII “元老”，只用一个字节表示。而像中文字符这样的，一般用三个字节表示。 now现在，因为 Unicode 编码占用空间多，所以在传输或存储时都使用了 UTF-8 编码，而在计算机内存中使用时，则使用着 Unicode 编码。比如我们在写代码的时候，在IDE中写入文件的代码，都是用 UTF-8 编码格式保存起来的。在编译运行时，这些字符被读取到内存中，此时用的编码格式则是 Unicode 。]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidTV开发 输入相关总结]]></title>
    <url>%2F2019%2F05%2F15%2Fandroid-tv-input-key%2F</url>
    <content type="text"><![CDATA[输入设备的按键事件，在Android设备中会被转换为KeyEvent对象。而游戏手柄中的摇杆则会产生对应的MotionEvent对象。 关于事件分发机制先大概看下事件的分发机制。简单来说，比如按键事件，分发按键事件的方法叫 dispatchKeyEvent() 。 一个事件首先被顶层DecorView分发给Activity，然后Activity会调用 dispatchKeyEvent() 方法将事件分发给ViewGroup层，在经过层层传递后，最终事件会到达我们想接受事件的View。View接受到事件后也会调用自己的 dispatchKeyEvent() 方法，然后就开始处理事件。默认情况下，会首先查看是否有给View设 OnKeyListener 。如果没有，或者有但是返回结果为false，那么事件还会继续交给View的 onKeyDown() onKeyUp() 等方法。如果为true，则事件立刻被消耗掉，后面不会再给其他方法了。其次，在交给 View 的 onKeyDown()和onKeyUp()方法后，如果这些方法又返回了false，那么事件不会被消耗掉，会进一步交给上层，最终在Activity的 onKeyDown() onKeyUp()方法中处理。而如果返回了true，则事件被消耗掉，事件处理就此结束。 监听事件对于按键事件，有以下方法可以来处理 onKeyDown() ： 按键按下 onKeyUp() ： 按下之后松开 onKeyLongPress()：长按 onKeyMultiple()：多次重复事件 onKeyShortCut()：快捷键事件 在长按的时候，首先会调 onKeyDown()，然后一般会连续调用onKeyDown()多次，或在调两次之后直接调用一次onKeyLongPress()方法一次就停止，这个可能与输入设备和按键有关。 不过，如果是要在Webview中监听按键事件，因为给Webview loadurl之后，KeyEvent就被消耗了，重写onKeyDown()等方法是接收不到事件的。所以还是建议直接重写 dispatchKeyEvent() 方法，这样可以从一开始就截获事件，不必担心不必要的麻烦。 对于游戏手柄中的摇杆事件，可以通过重写 dispatchGenericMotionEvent 方法来监听。 事件对象事件对象，包括按键事件 KeyEvent和摇杆事件MotionEvent。 KeyEvent一个KeyEvent对象，有以下属性： action : 按键的动作。有DOWN UP等keyCode : 按键代码，跟前面单独的KeyCode一样scanCode : 按键事件的原始设备扫描码，最终会转换为keyCodemetaState : 当前按键的metaStateflags : 当前按键事件的flagsrepeatCount : 按键事件重复的次数。有的按键在长按的时候，会连续产生多个DOWN事件，这个时候除第一个DOWN事件的repeatCount为0，之后的DOWN事件的repeatCount会递增。之所以是部分按键，是因为我发现键盘上的按键长按时，会被识别为 DOWN UP DOWN UP序列，而长按比如手机的虚拟按键时，事件序列是 DOWN DOWN UPeventTime : 这个事件发生的时间，是一个从开机到现在的毫秒数。downTime : 这个按键按下的时间，是一个从开机到现在的毫秒数。如果同一个按键先按下再弹起，那么他有两个事件，UP和DOWN，且这两个事件的downTime是一样的deviceId : 产生按键事件的设备deviceidsource : 输入源，具体可以参考 InputDevice类 这里keyCode有很多，除了基础的Android手机的几个虚拟按键外，还有整个键盘按键、游戏手柄按键、电视遥控器等，具体在官网有讲，也有一些靠谱的翻译： 官方文档翻译 摇杆事件一个MotionEvent对象，表示摇杆相关状态，常用的一些值，需要用 getAxisValue()方法通过传入不同的参数来获取当前值，此外有一些类似方法可以获取历史值。 AXIS_X参数，获取到x值，表示水平方向移动距离，向右为正，向左为负AXIS_Y参数，获取到y值，表示垂直方向移动距离，向下为正，向上为负AXIS_Z参数，获取到z值，表示水平方向移动距离，向右为正，向左为负AXIS_RZ参数，获取到rz值，表示垂直方向移动距离，向下为正，向上为负AXIS_BRAKE参数，获取到break值，表示肩键状态，1为按住 0为释放AXIS_GAS参数，获取到gas值，表示肩键状态，1为按住 0为释放负 官方文档翻译 键位映射键盘在接入键盘时，每个按键在按下、弹起时都有对应的 KeyEvent 对象，对应着一个事件，可以使用。 手柄在接入手柄时，有两种事件，分别是按键事件 KeyEvent和移动事件MotionEvent。 手柄中的常规按键，都会对应一个或多个 KeyEvent，而操作摇杆时，或者按下左右侧的L2 R2键时，会产生MotionEvent。其中按键事件不一定是一对一的，部分键是一次操作有多种按键事件。而移动事件可以获取当前摇杆的移动情况，用坐标形式来模拟，具体映射如下： X ： 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_X 和 KEYCODE_DEL。长按会继续产生 KEYCODE_DEL 按键事件。Y : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_Y 和 KEYCODE_SPACE。长按会继续产生 KEYCODE_SPACE 按键事件。A : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_A 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。B : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_B 和 KEYCODE_BACK。长按会继续产生 KEYCODE_BACK 按键事件。 ↑ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_UP。如果是长按，则会继续产生相同的按键事件，直到松开。↓ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_DOWN。如果是长按，则会继续产生相同的按键事件，直到松开。← ： 按下会先产生一个摇杆动事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_LEFT。如果是长按，则会继续产生相同的按键事件，直到松开。→ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_RIGHT。如果是长按，则会继续产生相同的按键事件，直到松开。 L1 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L1，长按继续产生相同事件。R1 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L2，长按继续产生相同事件。 L2 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L2，之后再产生一个摇杆事件，坐标移动量为0。长按继续产生相同的按键事件。松开后坐标移动量中 break 会变为1 R2 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_R2，之后再产生一个移动事件，坐标移动量为0。长按继续产生相同的按键事件。松开后坐标移动量中 gas 会变为1。 左摇杆 ：按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_THUMBL 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。拨动摇杆时，会连续产生多个移动事件。移动事件的x y值表示当前拨动的距离。 右摇杆 ：按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_THUMBL 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。拨动摇杆时，会连续产生多个移动事件。移动事件的z zr值表示当前拨动的距离。 手柄的适配情况，在主流的Xbox360类手柄上是完全适配的，Switch Pro类手柄的L2 R2键没有KeyEvent事件]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件加速]]></title>
    <url>%2F2019%2F03%2F21%2Fhardware-note%2F</url>
    <content type="text"><![CDATA[背景什么是硬件加速？ 硬件加速是Android系统在绘制图形时采取的一种方式。 图形的绘制，本质上就是界面的渲染。在渲染界面的时候，是要经过一系列计算的，这部分计算通常是逻辑较简单，但数据量庞大的浮点运算。 在操作系统层面，有一个东西叫中央处理器——CPU，他是计算机设备的核心器件之一，主要功能是解释计算机指令以及处理计算机软件中的数据。除此之外，计算机还有一个器件，叫做图形处理器——GPU，他类似于CPU，但是是专门为运行绘图运算的微处理器。 那么CPU和GPU的区别在哪里呢？ CPU内部算数逻辑单元（ALU）较少，控制器较复杂，适合进行复杂的逻辑运算 GPU控制器简单，但是包含了较多的算数逻辑单元，可并行运行大量计算 结果显而易见，因为界面渲染的计算是逻辑简单但是数据量很大的浮点运算，所以如果使用CPU来对界面渲染做运算，效果自然比不了GPU。 所以，硬件加速绘制图形是一般会采用的软件绘制就是由CPU来绘制的。硬件加速，就是通过底层代码，将CPU中一部分不擅长的图形计算转换成GPU专用指令，然后交给GPU来完成。而对于Android来讲，硬件加速就是将View的绘制工作从原来的CPU转交给GPU来做。 原理硬件绘制之所以比软件绘制“快速”，除了如上所述的奖一部分计算量交给更适合的硬件来做外，还有一个很重要的原因在于绘制区域即绘制内容的选择不一样。 在关闭了硬件加速，即采用软件绘制时，绘制区域是这样获取的：从要执行 invalidate() 方法的View开始，遍历从跟View开始的整个View结构，标记出需要重新绘制的 脏区域。在这个过程中，除了我们直接修改的View需要绘制外，其他的所有View，都可能因为遮盖、相交等原因，被标记为需要绘制，这样一来绘制的区域就会变的很大。这样一来一旦开始绘制，搞不好会有很多“无辜”的View也被重新绘制，虽然这些View未必真的需要被重绘。 而采用硬件加速时，就完全不一样了。硬件绘制，首先将View抽象为 RenderNode 节点，将对View的绘制，抽象为 DrawOp ，每个View不仅持有自己的绘制操作 DrawOp 组成的List，还持有其子View的绘制入口，而 DrawOp 中保存有对应的 OpenGL 绘制命令，这样便形成了一个完整的树状结构。其次，硬件绘制是直接交给一个Render线程来执行绘制的，而不是主线程，这样也缓解了主线程的部分压力。最后，在进行实际绘制时，每个View的实际绘制操作对应于 DrawOp ，在绘制时只需更新其中保存的绘制命令，即可完成这个View单独的绘制，而不会影响到其他View。 问题虽然硬件加速有很多优点，但是也有许多坑。 首先，一些Api方法是不支持硬件加速的： 其次，在使用Webview时，如果启用了硬件加速，那么有时会出现花屏、闪烁等异常状况。 最后，正如前面说的，由于不支持一些Api，所以在做自定义View时，有可能因为开启硬件加速导致View的绘制效果不理想。 如何使用一开始Android是默认关闭硬件加速的。从Android4.0版本开始，默认是开启了硬件加速的。硬件加速固然有很多优点，但是由于种种原因（系统设计、历史遗留、以及自身的局限性）导致在有些情况会出现一些问题，这个时候又需要我们手动关闭了。 硬件加速的开关分为四个级别，分别为App级别、Activity级别、Window级别以及View级别。 App级别：直接在 AndroidManifest.xml 文件中， &lt;application&gt; 标签下加入一个属性，属性值为 true 为开启， false 为关闭： 1&lt;application android:hardwareAccelerated="true"&gt; Activity级别：类似于App级别，在 &lt;activity&gt; 标签下加入同样的属性： 1&lt;activity android:hardwareAccelerated="true"&gt; Window级别： 在Window级别，只能通过Java代码形式动态的开启硬件加速而不能关闭： 1getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View级别:View层比较特殊，这里只允许关闭硬件加速，而无法开启。而且相关的接口并不是专门用来做硬件加速开关的，而是在给View设置Layer时“顺便”关闭了硬件加速： 1view.setLayerType(LAYER_TYPE_SOFTWARE, null); 这个方法只是给View设置了一个LayerType，而且参数有三种：LAYER_TYPE_SOFTWARE LAYER_TYPE_HARDWARE LAYER_TYPE_NONE，这是什么意思呢？关于这一部分，在官网中有详细的解释： You currently cannot enable hardware acceleration at the view level. View layers have other functions besides disabling hardware acceleration. See View layers for more information about their uses. 官方说在View层只能关闭，不能开启，至于为什么，引用一段扔物线大佬的解释： setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。 所以，如果给View设置了Layer，且值为SOFTWARE，那么就是用软件来做View Layer，自然就关闭了硬件加速。而如果硬件加速已经关闭，参数HARDWARE的作用跟SOFTWARE一样，自然也无法开启硬件加速。而值为NONE时，直接就关闭了ViewLayer，所以在View层只能关闭、不能开启，正如官方文档所说： LAYER_TYPE_NONE: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior. LAYER_TYPE_HARDWARE: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as LAYER_TYPE_SOFTWARE. LAYER_TYPE_SOFTWARE: The view is rendered in software into a bitmap.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>硬件加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对Git的一些理解]]></title>
    <url>%2F2019%2F02%2F24%2Flean-git%2F</url>
    <content type="text"><![CDATA[版本控制基本的版本控制，其实就类似于编写文档时的撤销和回退，在需要的时候将当前文本内容变为历史内容。所以程序代码的版本控制系统，核心就在于要保存历史记录，并有一个索引指向代码的各个历史版本，并能够通过索引随时将当前项目的内容替换为历史版本的内容。 VCS和DVCS常见的版本控制系统，无非就是SVN和Git了，前者是中央式版本控制系统（VCS），后者是分布式版本控制系统（DVCS）。 中央式版本控制系统，大致是这样的：一个项目，所有内容都存放在服务器上的代码仓库中，叫做中央仓库。团队中的每个成员，都可以从服务器获取到一份代码，进行开发。每个人在开发完成后，都需要将自己的新代码提交到服务器上的远程中央仓库中。每当有人提交代码，其他人都可以讲这些更新的代码同步到自己的机器上，来保证项目代码的版本同步。 在分布式版本控制系统下工作流程大致是这样的：一个项目的所有内容存放在服务器上的代码仓库中，即中央仓库。团队中每个成员从服务器获取到一个与远程仓库一模一样的代码仓库，叫做本地仓库。接下来，每个人可以在自己电脑上进行开发，开发完成后的新代码可以直接提交到自己的本地仓库中，和远程仓库完全没有关系，因此这一步也就是离线的。在需要的时候，每个人可以将本地仓库与远程仓库做一次同步，让远程中央仓库保持跟本地仓库一致。每当有人这样提交后，其他成员都可以将自己的本地仓库与远程中央仓库做一次同步，让本地仓库与其保持一致，这一过程是需要联网操作的。 分布式版本控制系统，大体上和中央式是一样的，区别就在于，在中央式版本控制系统中，远程的中央仓库全权负责了历史版本的控制，每个人只能从仓库中获取代码，想仓库上传新代码，仅此而已。而分布式版本控制系统中，每个团队成员从远程中央仓库获取到的不是简单的一份代码，而是一个完整的代码仓库，叫做本地仓库，这个本地仓库保存了整个项目的所有版本信息，就相当于一个远程仓库。 GitGit就是一种广泛使用的分布式版本控制系统，除了免费的GitHub外，各个公司、团队可以以Git为基础定制化自己的一套系统。Git做版本控制时，他所管理的版本历史记录，不是你代码的记录，而是代码改动的记录。即他不会记下你某个时间点代码内容是什么样的，他记录的是在那个时间点代码有什么样的变动。 常见工作模型目前常见的Git工作模型大致是这样的： 先由主工程师完成基础框架，并将代码推送至服务器上，作为中央仓库 中央仓库的代码会有多个分支，比如master,dev等 每个成员需要从中央仓库clone一个本地仓库 项目的开发工作，基本都是在dev分支做。当完成一个版本的开发后，会合并到master分支 每个成员开发时，都需要从dev分支建立属于自己的分支，在这个分支上进行开发 成员在开发完成一个小功能时，需要提交代码至自己的本地仓库中 在完成一个大模块的开发后，需要将本地仓库同步至远程仓库 每个成员在开发过程中药注意保持自己本地仓库与远程仓库同步 提交代码：add 和 commit在使用Git时，最常见的命令就是 add 和 commit 了。Git中有一个叫做 暂存区（stage） 的东西。每当有新的代码改动，都需要先执行 add 命令将改动加入到暂存区。 add 时，可以指定要加入的内容，比如 add xxx.txt ， 也可以偷偷懒一次全部加入 add -A 或 add . 。在加入到暂存区之后，还可以继续开发，也就是可以有多次 add ，每次 add 都会将部分改动加入到暂存区。当你觉得差不多了，可以执行一次 commit ，也就是将当前暂存区内的所有改动，统一标记为一次提交，提交至本地仓库中。在提交后，会自动生成一个字符串，作为这次提交的索引，叫做 commit id 。 而这次提交所生成的 commit ，就相当于一个指针或者引用，指向了这一次提交。 随着工作的进行，会有很多很多 commit 引用，我们只需要知道 commit 对应的id，或者其他手段，获取到这个指针/引用，就可以获取到“在那次提交时项目的代码是怎么样的”。 引用：HEAD 和 branch前面说 commit 是一种引用，其实Git中除了 commit 之外，还有许多种引用。 首先是 HEAD ，这个引用非常特殊。由于我们有多次提交，也就生成了多个 commit 引用。而 HEAD 引用则指向了当前的 commit 引用，也就是他是指向了引用的引用。当前在哪个 commit 引用上， HEAD 就指向哪里，始终保持在当前。 还有一个引用，叫做 branch 。这个引用可以叫做分支，指向一个 commit ，即他也是指向引用的引用。前面说的 HEAD 除了直接指向 commit 外，也可以指向 branch 引用。 branch 是可以通过执行 git checkout -b xxx 或者 git branch xxx 来任意创建的。在创建一个 branch 之后，可以主动将 HEAD 指向这个引用，之后在开发中，每当有新的提交，新的 branch 将会始终指向新生成的 commit 引用。 系统默认会有一个 branch 引用，名字叫做 master ，这个引用是在创建代码仓库时就创建好的（当然可以自己定制，不过大部分情况默认就叫做master），他是整个项目的主分支，也就是主引用。大多数团队会规定，以 master 为核心，在 master 分支下必须是能对外发布的、功能完整的项目。 一图胜千言，看下如图所示的工作流： 在图中，123456789分别是9个 commit 引用， master 引用指向的3是当前稳定的版本，而 branch1 和 branch2 则分别是两个用来开发新功能的 branch 引用，此时由于 HEAD 引用指在了 branch1 这个引用上，所以当前工作目录下的代码也就是6所对应。 合并代码：merge 和 rebase为了安全与规范，通常会留一个 master 分支作为一个项目的稳定版本， dev 分支作为一个开发版本，成员基于 dev 分支开发时，要再建一个 feature 分支，并在这个分支进行开发。当然，还有一些更细致的方式，归根结底都是要以分支为单位进行开发。那么在开发完成后，就需要将完成的功能合并到主分支。这里的主分支是相对而言的，可能是小功能的 feature ，可能是 dev ，也可能是 master 。在合并是通常有两种方式， merge 和 rebase 。 第一种 merge ，作用是将两个分支的提交合并在一起，作为一个新的提交。如图所示： 此时 branch1 开发完成，当前工作目录在 master 分支，在这里执行 merge 后的效果： 会自动把从分叉点3开始的提交，67和 master 上的提交 45 做合并，并生成一个新的提交8。当然在合并时可能存在冲突，就需要主动解决冲突了。 第二种 rebase ，可以译作变基，也就是将当前一系列提交的基础提交改变为目标分支，如图所示： 此时切换到开发完成的 branch1 分支下，执行 rebase 然后再在 master 下执行 merge 后的效果： branch1 分支的提交67的基础点会被移动到 master 上，也就是5上。然后将 HEAD 移动到 master 引用上执行 merge ,就将 master 引用又移到了最新的 commit 上。 这两者用法都可以， merge 简单好理解一些，因此大部分人都是在用 merge 。但是无脑的 merge 导致的问题就是提交记录中会出现很多分叉路线，比较混乱难以管理，因此我了不出现分叉，最好用 rebase 来替代 merge 。 对了， merge 有一种特殊情况，就是如果 merge 执行时的目标分支和当前分支并没有分叉，也就是他们其实是在一条分支上，此时有两种情况：如果当前 HEAD 指向的引用领先于目标分支，那么这时的 merge 是一个空操作。而如果是落后于目标分支，那就是一个被称为“快速前移（fast-forward）”的操作，将当前 HEAD 指向往前移动到目标引用处。 同步仓库：pull 和 push在本地仓库开发完成并向远程仓库同步时，要使用 push 。 笼统的说， push 就是拿本地仓库去覆盖掉远程仓库。当然如果有冲突的话，这一请求会被拒绝掉。实际上， push 命令所做的是：将当前分支，也就是 HEAD 所指向的分支，提交到远程仓库，同时将这一分支上的所有提交也一并提交到远程仓库去。 HEAD 指向 master 这样远程仓库已经存在的分支，那就相当于是更新了远程仓库的分支的提交记录。 而如果指向了其他远程仓库不存在的分支，比如新的 feature1 ，此时就会更新远程仓库信息，告诉他：现在多了一个分支，这个分支有哪些改动。之后其他成员从远程仓库同步下来之后，也得到了你的新的分支信息。 从远程仓库同步下来的操作是 pull 。不过 pull 其实不是一个命令，他内部其实分为了两步。如果不执行 pull ，也可以分别通过这两个命令来实现 pull 的功能，这两个命令就是 fetch 和 merge 。 第一步， git fetch ，他的作用是更新本地仓库关联的所有远程仓库中，各个分支的一系列提交记录。这里只是获取到，并不会有其他操作。第二步 merge ，则是将当前的本地提交与获取到的远程仓库的提交做一个合并，这就是上面说到的 fast-forward 的典型。一般情况下，直接 pull 更简单省事。但是一旦出现冲突，由于会自动的进行 merge ，自动的合并之后可能会出现很多问题，需要自己一个一个查。而如果先 fetch 之后，再查看一下有哪些更新，此时再手动 merge ，就会好很多。 注意事项在一个团队中使用Git时，一定要细心，中央仓库在服务器上占用的资源是有限的，稍有不慎将一些无用的大体积文件上传到服务器都会造成很大的问题。我这里总结一些经验： 尽量少使用 git add -A 每次 add 和 commit 前后都要注意检查是否有没必要提交的内容 本地 commit 时要做好 code-review 提交代码，慎用 push -f 遇事不决先建个分支，这样不管出什么问题起码不会影响到别人 执行 commit 时填写的 commit信息 一定要规范 分支名很重要，不能乱起 不用的、弃用的、开发完的一些分支，该删的删，留到后面管理会比较乱 其他在工作中使用Git的过程中，可能会对一些其他的地方有新的理解，到时候再在后面更新吧，比如常见的一些命令 cherry-pick 、 rebase 等]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于时间 需要了解的一些东西]]></title>
    <url>%2F2019%2F02%2F11%2Ftime-standard%2F</url>
    <content type="text"><![CDATA[时间什么是时间？维基百科是这么说的： 时间是一种尺度，在物理定义是标量，借着时间，事件发生之先后可以按过去-现在-未来之序列得以确定（时间点），也可以衡量事件持续的期间以及事件之间和间隔长短（时间段)。 时间有多种仪器用来记录，比如太阳钟、机械表等。目前时间的基本国际单位为 秒 ，以铯133原子基态的两个超精细能级间跃迁对应的辐射的9,192,631,770个周期的持续时间为标准。 时间标准国际标准ISO 8601，是国际标准化组织的日期和时间表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法。 对应于世界各地： 中华人民共和国国家标准GB/T 7408-2005《数据元和交换格式 信息交换 日期和时间表示法》与ISO 8601:2000等效采用。中华民国国家标准CNS 7648《资料元及交换格式·资讯交换·日期及时间的表示法》与ISO 8601:2004等效采用。 格林尼治平时格林尼治平时，即GMT(Greenwich Mean Time)，是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。 协调世界时协调世界时，即UTC（Coordinated Universal Time),是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。中华民国采用CNS 7648的协调时间，中华人民共和国采用GB/T的协调时间。 协调世界时是世界上调节时间和时钟的主要时间标准，与0度经线的平太阳时相差不过1秒，不遵守夏令时。 如果本地时间比UTC时间快，例如中国大陆、香港、澳门、台湾等，时间比UTC快8小时，就会写作UTC+8，俗称东八区。相反，比UTC慢，例如夏威夷比UTC慢10小时，就会写作UTC-10，俗称西十区。 夏令时夏时制，也叫夏令时，是一种为节约能源而人为规定地方时间的制度，在这一制度期间所采用的统一时间称为“夏令时间”。一般在天亮较早的夏季，人为将时间调快一个小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。不同国家队夏令时的规定及使用各有不同。 系统时间计算机科学与计算机编程中，表示计算机系统中的时间与日期，通常用系统时钟从某个时间起点的嘀嗒数表示。其中，类Unix系统采用世界标准时间1970年1月日00:00:00开始的秒数作为Unix时间，Windows使用SYSTEMTIME标识年月日时分秒毫秒，使用FILETIME表示自世界标准时1601年1月1日00:00:00开始的100纳秒为单位的时钟嘀嗒数。 Unix时间Unix时间，又称为POSIX时间，时间戳（timestamp），是一种时间的表示方式，定位如上，严格来说，不管在地球上的那个一个地方，任意时间点的时间戳都是相同的。 Unix时间戳已经广泛应用于各种类Unix系统中，但是会存在一个2038年问题。即，由于大部分Unix系统时间都是32位的，到2038年时会发生溢出，导致时间为负，因此在2038年前，所有的采用了32位Unix时间的应用都需要采用新的时间戳规范，或者迁移到64位系统。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UTC</tag>
        <tag>GMT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读权限标签 &ltpermission&gt 和 &ltuses-permission&gt]]></title>
    <url>%2F2019%2F01%2F17%2Fandroid-permission%2F</url>
    <content type="text"><![CDATA[最近在项目中遇到一个问题，不同的包在安装时有冲突，后一个安装的应用会被提示已经有相同的权限被声明了，因此无法安装。看了下两个包的 AndroidManifest.xml 文件，确实有相同名称的 &lt;permission&gt; 和 &lt;uses-permission&gt; 标签。那么这个 &lt;permission&gt; 标签和 &lt;uses-permission&gt; 标签有什么区别呢？ 权限首先，什么是权限？我有一个应用A，一个应用B，现在应用A想使用应用B的一些功能，那么Android系统为了安全起见，肯定不能让我们随便就调用了。应用B必须先声明一些权限，对应于开放给外界调用的功能。应用A要用，必须要先注册这些权限，相当于获取了一块通行证。 我们在 AndroidManifest.xml 文件中所见到的权限标签有两种， &lt;permission&gt; 和 &lt;uses-permission&gt; 。他们的区别，在官网文档有很详细的解释： &lt;permission&gt; &lt;uses-permission&gt; 大概总结一下，就是 &lt;permission&gt; 标签用来声明、定义一个权限，而 &lt;uses-permission&gt; 标签用来申请一个权限。除此之外，还有一些权限相关的标签，比如 &lt;permission-group&gt; 和 &lt;permission-tree&gt; ，这两个都是和 &lt;permission&gt; 相关的。其中 &lt;permission-group&gt; 用来声明一个权限组，在定义单个具体权限时可以将其分配到指定的权限组中，这样一个权限组就包含了多个具体权限。当申请权限组中一个单个权限成功时，同一个组内的其他权限也会自动获取到，可谓“一荣俱荣”。另外一个标签 &lt;permission-tree&gt; 则是为一组权限声明一个基础的命名空间，相当于一组权限的前缀，是可以用代码动态添加的，而且其名字必须要至少两个 . 符号。 permission1234567&lt;permission android:description="string resource" &lt;!--描述信息（展示给用户）--&gt; android:icon="drawable resource" android:label="string resource" &lt;!--权限的名称（展示给用户）--&gt; android:name="string" &lt;!--权限的名称（唯一标示）--&gt; android:permissionGroup="string" &lt;!--所属权限组--&gt; android:protectionLevel=["normal" | "dangerous" | &lt;!--权限等级--&gt; "signature" | ...] /&gt; 这里要注意一点， name 属性必须是唯一的！官方文档是这么说的： Note: The system does not allow multiple packages to declare a permission with the same name, unless all the packages are signed with the same certificate. If a package declares a permission, the system does not permit the user to install other packages with the same permission name, unless those packages are signed with the same certificate as the first package. To avoid naming collisions, we recommend using reverse-domain-style naming for custom permissions, for example com.example.myapp.ENGAGE_HYPERSPACE. 也就是说，这一名称在系统中是唯一的，他是什么在系统中注册的就是什么，和你的包名什么的没有关系。因此Google建议采用和包名类似的命名方式。 此外， protectionLevel 这一属性表示这一权限的等级，不同等级的权限有不同的待遇： normal: 任何应用都可以申请这一权限，而且在安装时默认授予，不会直接给用户提示 dangerous：任何应用都可以申请这一权限，但是会给用户提示，在5.0 6.0以后的系统，甚至需要应用动态获取，而无法再安装时一次获取 signature：只有与声明这一权限的应用使用了相同的私钥签名的应用才可以申请。 signatureAndSystem：除了满足signature的应用可以申请外，存放在系统目录 /system/app 目录下也可以申请。 难怪我们安装时会提示权限冲突，原来是因为有两个 &lt;permission&gt; 标签使用了相同的 name 值。 uses-permission&lt;uses-permission&gt; 权限的相关属性就简单的多： 12&lt;uses-permission android:name="string" &lt;!--权限名称--&gt; android:maxSdkVersion="integer" /&gt; &lt;!--权限需要的最大Sdk版本--&gt; 这里的 name 属性所指的便是由 &lt;permission&gt; 标签所声明时使用的 name 属性了。 所以权限冲突和这一标签是没关系的。亲测之后发现，只要不存在相同的 &lt;permission&gt; ，即使存在两个一样的 &lt;uses-permission&gt; 也是可以的。 举个栗子在源码目录的 frameworks/base/core/ 目录下的 AndroidManifest.xml 文件中，声明了一些系统常见的权限。这儿截取一部分来看： 12345678910111213141516171819202122232425262728293031323334&lt;!-- ====================================================================== --&gt; &lt;!-- RUNTIME PERMISSIONS --&gt; &lt;!-- ====================================================================== --&gt; &lt;eat-comment /&gt; &lt;!-- ====================================================================== --&gt; &lt;!-- Permissions for accessing user's contacts including personal profile --&gt; &lt;!-- ====================================================================== --&gt; &lt;eat-comment /&gt; &lt;!-- Used for runtime permissions related to user's contacts and profile. --&gt; &lt;permission-group android:name="android.permission-group.CONTACTS" android:icon="@drawable/perm_group_contacts" android:label="@string/permgrouplab_contacts" android:description="@string/permgroupdesc_contacts" android:priority="100" /&gt; &lt;!-- Allows an application to read the user's contacts data. &lt;p&gt;Protection level: dangerous --&gt; &lt;permission android:name="android.permission.READ_CONTACTS" android:permissionGroup="android.permission-group.CONTACTS" android:label="@string/permlab_readContacts" android:description="@string/permdesc_readContacts" android:protectionLevel="dangerous" /&gt; &lt;!-- Allows an application to write the user's contacts data. &lt;p&gt;Protection level: dangerous --&gt; &lt;permission android:name="android.permission.WRITE_CONTACTS" android:permissionGroup="android.permission-group.CONTACTS" android:label="@string/permlab_writeContacts" android:description="@string/permdesc_writeContacts" android:protectionLevel="dangerous" /&gt; 拿通讯录权限举例。首先这里声明了一个权限组 android.permission-group.CONTACTS 。之后，分别定义了一个通讯录的读权限、一个通讯录的写权限，且他们的 permissionGroup 属性都指向了刚刚声明的权限组名称。因此，这两个权限便同属于一个权限组。此外，看看 label 和 description 属性的值是什么。在同级的 res 目录下可以看到各种语言版本的 strings.xml 文件，看看中文版怎么说吧： &lt;string name="permlab_readContacts" msgid="8348481131899886131"&gt;"读取您的通讯录"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="tablet" msgid="5294866856941149639"&gt;"允许该应用读取您平板电脑上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定个人通信的频率。此权限可让应用保存您的联系人数据，而恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="tv" msgid="1839238344654834087"&gt;"允许应用读取您的电视上存储的联系人相关数据，包括您与特定联系人通话、发送电子邮件或通过其他方式进行通信的频率。此权限可让应用保存您的联系人数据，而且恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="default" msgid="8440654152457300662"&gt;"允许该应用读取您手机上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定个人通信的频率。此权限可让应用保存您的联系人数据，而恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permlab_writeContacts" msgid="5107492086416793544"&gt;"修改您的通讯录"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="tablet" msgid="897243932521953602"&gt;"允许该应用修改您平板电脑上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定联系人通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="tv" msgid="5438230957000018959"&gt;"允许应用修改您的电视上存储的联系人相关数据，包括您与特定联系人通话、发送电子邮件或通过其他方式进行通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="default" msgid="589869224625163558"&gt;"允许该应用修改您手机上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定联系人通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; 就很清楚了，在应用主动请求获取这一权限时，会弹出一个dialog，询问用户是否给予这一权限。而dialog的内容，便是由这儿的 label 和 description 组成的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好 2019]]></title>
    <url>%2F2019%2F01%2F06%2Fhello-2019%2F</url>
    <content type="text"><![CDATA[永远爱着高欢芝~ 坚持记录博客 运动-锻炼身体-减肥-不驼背-不伸脖子 养成早上七点起 晚上十一点睡觉好习惯 不熬夜 学习Kotlin，至少能到用kotlin编写一个简单app的程度 阅读Android系统主要模块的源码并整理笔记 看完10+本技术书籍 看完50+本其他类型书籍 自学完经济学 练习书法，学习古典音乐鉴赏 坚持阅读英文报刊]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结目前常见的Crash日志收集工具]]></title>
    <url>%2F2018%2F12%2F08%2Fsurvey-crash-report%2F</url>
    <content type="text"><![CDATA[调研结果 接入 上传 错误类型 错误参数 高级检索 统计分析 收费 其他亮点 Bugly 简单 及时 丰富 用户、渠道、标签 丰富 中等 免费 可捕捉JS异常 网易云捕 简单 及时 丰富 用户、渠道、标签 丰富 详细 收费 体积小速度快 友盟 U-APP 简单 较慢 JAVA 用户、渠道、标签 简略 中等 免费 提供了开关接口 Bugtags 复杂 较慢 丰富 自定义键值对 简略 简略 部分收费 可上传截图，操作步骤 蒲公英 简单 较慢 JAVA 收费 用户可主动上报bug Testin 简单 及时 丰富 用户、渠道、标签 丰富 详细 免费 可上传截图 Crasheye 简单 及时 缺少ANR 用户、渠道、标签 丰富 详细 免费 可捕捉脚本异常 LogReport 简单 及时 缺少ANR 免费 Gitub开源项目 CrashReporter 简单 及时 缺少ANR 免费 Github开源项目 ACRA 麻烦 及时 缺少ANR 免费 Gitub开源项目xq Flurry 简单 不稳定 丰富 自定义键值对 简略 详细 免费 分析图片很详细 crashlytics 复杂 不稳定 自定义键值对 丰富 详细 免费 bugsnag 简单 不稳定 自定义table 丰富 详细 按功能收费]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SDK for Unity]]></title>
    <url>%2F2018%2F11%2F19%2Funity3d-android-sdk%2F</url>
    <content type="text"><![CDATA[原理生产apk首先新建一个Unity项目，写一个简单的游戏界面: 然后用Unity导出为apk: 我们的游戏运行起来之后，首先展示的就是这个主界面了： 所以猜测，如果将他转换为我们熟悉的Android项目，那么这个游戏界面就应该对应着MainActivity了。接下来验证一下。 解析apk使用apktool工具，解析apk文件，然后打开其中的AndroidManifest.xml文件，文件内容如下： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="28" android:compileSdkVersionCodename="9" android:installLocation="preferExternal" package="com.levent_j.sdk_jar" platformBuildVersionCode="28" platformBuildVersionName="9"&gt; &lt;supports-screens android:anyDensity="true" android:largeScreens="true" android:normalScreens="true" android:smallScreens="true" android:xlargeScreens="true"/&gt; &lt;application android:banner="@drawable/app_banner" android:debuggable="false" android:icon="@mipmap/app_icon" android:isGame="true" android:label="@string/app_name" android:theme="@style/UnityThemeSelector"&gt; &lt;activity android:configChanges="density|fontScale|keyboard|keyboardHidden|layoutDirection|locale|mcc|mnc|navigation|orientation|screenLayout|screenSize|smallestScreenSize|touchscreen|uiMode" android:hardwareAccelerated="false" android:label="@string/app_name" android:launchMode="singleTask" android:name="com.unity3d.player.UnityPlayerActivity" android:screenOrientation="landscape"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;category android:name="android.intent.category.LEANBACK_LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="unityplayer.UnityActivity" android:value="true"/&gt; &lt;/activity&gt; &lt;meta-data android:name="unity.build-id" android:value="25b7b97f-87c9-4c20-8185-b8dbd0337926"/&gt; &lt;meta-data android:name="unity.splash-mode" android:value="0"/&gt; &lt;meta-data android:name="unity.splash-enable" android:value="true"/&gt; &lt;/application&gt; &lt;uses-feature android:glEsVersion="0x00020000"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen" android:required="false"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen.multitouch" android:required="false"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen.multitouch.distinct" android:required="false"/&gt;&lt;/manifest&gt; 果然，被标识为应用入口的MainActivity出现了，就是这里的UnityPlayerActivity。这个UnityPlayerActivity，放在Unity安装目录下的一个classes.jar包中。因此我们如果想在Android端做一些事情，就一定需要依赖这个classes.jar文件。所以，我们需要复制这一文件，把他当做一个外部依赖包，导入到Android项目中。 这一文件的具体位置不同系统不一样，不过一般都是在Unity的安装目录下。比如Mac OS下，具体路径为： 1/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes 复制这一目录下的classes.jar，然后在Android项目中导入。导入之后，就可以查看其中的代码了。 UnityPlayerActivity是什么1234567891011121314151617181920212223242526272829303132333435public class UnityPlayerActivity extends Activity &#123; protected UnityPlayer mUnityPlayer; public UnityPlayerActivity() &#123; &#125; protected void onCreate(Bundle var1) &#123; this.requestWindowFeature(1); super.onCreate(var1); this.mUnityPlayer = new UnityPlayer(this); this.setContentView(this.mUnityPlayer); this.mUnityPlayer.requestFocus(); &#125; protected void onNewIntent(Intent var1) &#123; this.setIntent(var1); &#125; protected void onDestroy() &#123; this.mUnityPlayer.quit(); super.onDestroy(); &#125; protected void onPause() &#123; super.onPause(); this.mUnityPlayer.pause(); &#125; protected void onResume() &#123; super.onResume(); this.mUnityPlayer.resume(); &#125; //忽略了其他的冗余代码&#125; 可以看到，这个Activity继承自Activity，持有一个UnityPlayer对象的引用，并且在onCreate()方法中调用UnityPlayer的构造器，传入自己的引用，创建了这一对象，然后在调用setContentView()方法将UnityPlayer当做本Activity所显示的View。之后该Activity的所有生命周期方法，实际上都调用了UnityPlayer的对应方法。那么来看看这个UnityPlayer为何物： 1234567891011121314151617181920212223public class UnityPlayer extends FrameLayout implements com.unity3d.player.f &#123; public static Activity currentActivity = null; private Camera2Wrapper q = null; private Context r; private SurfaceView s; public UnityPlayer(Context var1) &#123; super(var1); if (var1 instanceof Activity) &#123; currentActivity = (Activity)var1; this.c = currentActivity.getRequestedOrientation(); &#125; a(currentActivity); this.r = var1; if (currentActivity != null &amp;&amp; this.i()) &#123; this.m = new l(this.r, com.unity3d.player.l.a.a()[this.getSplashMode()]); this.addView(this.m); &#125; //忽略其他代码 &#125; //忽略其他代码&#125; 原来这个UnityPlayer继承自FrameLayout，所以他可以在刚才被当做参数传给setContentView()方法。而在构造器中可以看到，将传入的Activity的引用，也就是Context的引用，用一个叫currentActivity（记住这个名字）的变量保存起来了。 总结一下，Unity项目导出Android项目后，主界是UnityPlayerActivity，是一个Activity。Activity所展示的界面，是通过一个叫做UnityPlayer的FrameLayout渲染的。所以我们如果想在Android端对这个主Activity做手脚，只需要继承UnityPlayerActivity即可。 Android端的处理模拟需求经过上述分析，我们知道了大致的原理，接下来就是实际行动了。我们假设要在Android端写一个SDK，让Unity项目在接入SDK后生产的游戏，在启动后首先显示由Android端控制的SplashActivity，之后再跳转至游戏的主界面。在游戏主界面中，通过点击按钮来调用Android端的方法。在Android端，再通过回调机制，调用Unity端的方法。以此，来实现两端的互相调用。 准备工作首先创建一个Android项目。之后，在项目中创建一个Module，并选择Android Library： 这个Module就是我们的SDK项目了。 创建成功之后，先导入之前提到过的classes.jar。导入成功之后创建两个Activity，分别为SplashActivity和UnityActivity： SplashActivity作为应用的入口，提供一个闪屏的作用，UnityActivity作为跳转之后的主Activity。因此，在AndroidManifest中这样注册他们： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.levent_j.sdk_jar"&gt; &lt;application android:allowBackup="true" android:label="@string/app_name" android:supportsRtl="true" android:name=".DemoApp"&gt; &lt;activity android:name=".SplashActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".UnityActivity"&gt; &lt;meta-data android:name="unityplayer.UnityActivity" android:value="true" /&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 注意，SplashActivity要加上作为应用入口的&lt;intent-filter&gt;标签，而UnityActivity作为游戏界面，需要加上&lt;meta-data&gt;标签： &lt;meta-data android:name=&quot;unityplayer.UnityActivity&quot; android:value=&quot;true&quot; /&gt; ###Activity如何处理 因为SplashActivity就是一个普通的Activity，所以继承Activity就可以了，而UnityActivity则需要继承UnityPlayerActivity： public class SplashActivity extends Activity public class UnityActivity extends UnityPlayerActivity 由于SplashActivity是闪屏界面，需要跳转到主界面，所以延时几秒直接跳转也好，点击按钮跳转也好，只要最后通过Intent启动了UnityActivity即可。我是这样写的： 123456789101112131415161718192021222324public class SplashActivity extends Activity&#123; @Override protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_splash); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; openActivity(); &#125; &#125; &#125;).start(); &#125; private void openActivity() &#123; UnityActivity.openActivity(this); &#125;&#125; openActivity(): 1234public static void openActivity(Context context) &#123; Intent intent = new Intent(context,UnityActivity.class); context.startActivity(intent);&#125; UnityActivity因为继承自UnityPlayerActivity，所以在onCreate()方法中无需设置界面。因为需要和Unity做交互，所以需要提供一些接口方法供外部调用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UnityActivity extends UnityPlayerActivity&#123; private Handler handler; @SuppressLint("HandlerLeak") @Override protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); //创建好一个Handle handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; payResult(); &#125; &#125;; &#125; //提供一个同步的 登陆接口 public String login()&#123; return "jar login success"; &#125; //提供一个同步的 退出登录的接口 public String logout()&#123; return "jar logout success"; &#125; //提供一个异步的 支付接口 public void pay(String amount)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; handler.sendEmptyMessage(0); &#125; &#125; &#125;).start(); &#125; public void payResult()&#123; UnityPlayer.UnitySendMessage("GameObject","payResult","pay success"); &#125;&#125; 这里注意，同步接口很简单，正常写一个方法即可。如果要让为Unity提供异步接口，我的做法是开启一个线程模拟一些后台的耗时操作，在执行结束后，通过UnityPlayer提供的一个方法来通知Unity，这一方法就是UnityPlayer的静态方法UnitySendMessage()方法： UnityPlayer.UnitySendMessage(&quot;GameObject&quot;,&quot;payResult&quot;,&quot;pay success&quot;); 这个方法接受三个参数，第一个参数是GameObject的名称，即我们在Unity项目中定义的一个GameObject的名称。第二个参数是GameObject所关联脚本中需要被调用的方法，即我们实际上需要在Android中调用的Unity中的方法的方法名，最后一个参数是调用这个方法时传入的参数。如图是我在Unity中创建的GameObject: 以及所关联的脚本中的方法： 123 public void payResult(string result) &#123; mContent.text = result;&#125; 两个Activity写好，就算可以了，当然也可以额外再加一个自定义的Application，因为有些时候可能会需要在这里做一些全局的初始化的工作。接下里就需要导出了。 导出sdk将编写好的代码导出为可以用的SDK，实际上是导出为jar包或者aar包。两者的区别在于，导出jar包的话，需要再将项目中的AndroidManifest文件和res目录一起，作为资源文件，copy并导入到Unity项目中，略微有点麻烦。而导出为aar包的话，直接将aar包导入即可，比较简单，但是在导入前需要通过压缩软件打开而不是解压aar文件，删除其中的libs目录下的classes.jar文件。如果不这么做会在Unity打包时出现冲突异常。按理说，我们在一开始直接导入classes.jar包时，如果选择了compileOnly形式的话，就可以避免这一步骤，但是我试了试好像行不通。所以虽然麻烦点，导出jar包这一方案还是很好的。 首先，需要编辑Module目录下的build.gradle文件，加入导出自己jar包的脚本代码： 12345678910111213141516171819202122// 定义SDK包名称def SDK_BASENAME = "UnitySDKDemo"// 定义SDK包版本def SDK_VERSION = "_V1.0.0"// SDK包生成地址def SDK_PATH = "build/libs"// 删除之前的Jar包 保证每一次生成的都是最新的task deleteOldJar(type: Delete) &#123; delete SDK_PATH + SDK_BASENAME + SDK_VERSION + '.jar'&#125;task exportJar(type: Copy) &#123; // 从源地址拷贝 from('build/intermediates/packaged-classes/release/') // 存放 into(SDK_PATH) // 导入 include('classes.jar') // 重命名 rename('classes.jar', SDK_BASENAME + SDK_VERSION + '.jar')&#125;// 执行脚本文件exportJar.dependsOn(deleteOldJar, build) sync之后，在右侧的gradle task列表中，就出现了上面定义的名为exportJar的Task: 找到这个task，双击执行后，等待build： 然后找到Module的build/libs目录，我们的jar包就导出成功了。 Unity的接入在Unity项目的Project窗口中可以看到项目目录，在Assests目录下新建一个目录Plugins，在Plugins目录下新建一个目录Android，再在Android目录下新建一个目录libs目录，如图： 这个Plugins目录就是我们接入iOS或者Android所需的插件目录。接下来直接把刚才的jar包拖到这个Plugins/Android/libs目录下。注意一定要手动拖进来，因为Unity会自动创建一个相关的文件，这一文件如果自己打开文件管理器复制粘贴的话是无法自动生成的。然后，再用同样的方法将Module中的AndroidManifest.xml文件和res目录拖到Plugins/Android目录下： 现在Andorid的插件已经导入成功了，需要再编辑Unity的脚本来使用了。由于前面我们看到，UnityPLayer对象有一个名叫currentActivity的变量，保存着对Activity的引用，所以如果要调用Activity中的方法，只需要获取到这个变量即可，因此在Unity端需要调用Android端方法的地方，这样处理即可： 123456789public void Login() &#123; Debug.Log(&quot;login&quot;); AndroidJavaClass jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;); string result = jo.Call&lt;string&gt;(&quot;login&quot;); mContent.text = result; &#125; 前两步的目的是获取到Android项目中UnityActivity的引用，获取到之后就可以任意调用其中的方法了，也就是直接调用AndroidJavaObject的Call系列方法。之所以说是系列，是因为我们Android端的方法有很多类型，静态的、实例的、有返回值的、无返回值的、有参数的、无参数的，这些都可以用Call方法来搞定： 12345678//返回值为string的实例方法string result = jo.Call&lt;string&gt;(&quot;login&quot;);mContent.text = result;//无返回值，但是需要传参的实例方法string money = mInput.text;jo.Call(&quot;pay&quot;,money);mContent.text = &quot;支付中……&quot;; 最后，再设置一下构建时的设置，将package name替换为Android SDK的包名。然后就可以直接打包apk并运行了:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unity3d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android打包相关知识整理（二）]]></title>
    <url>%2F2018%2F11%2F02%2Fandroid-pack-app-2%2F</url>
    <content type="text"><![CDATA[MultidexDalvik执行的是由多个.class文件合并成的一个.dex文件，而在这其中，会对.dex包中所有的方法通过方法ID做一个索引，存储在一个链表中，而这个链表的长度用一个short类型来保存。short类型占两个字节，所以一个short最大值应该是65536，因此如果我们一个包中的方法数如果太多，以至于链表索引的长度超过了65546，就会有问题。虽然在新版本中Google已经修复了这一问题，但是为了兼容低版本系统，我们需要在方法数超过这一限制时做一些处理。解决方法有很多，其中有一条就是分割dex，即如果一个dex放不下，就多分几个dex包，这样就不会有问题了。Google官方推出了multidex方案，可以有效的进行dex分包。multidex的原理很简单，在打包时主动分包，分为一个主dex包和多个次dex包，然后一起打包成apk。在应用启动时，会首先加载主dex包作为入口，然后依次加载次dex包。 配置使用配置使用很简单，分为两步： 修改Gradle配置，使项目支持multidex。 123456789101112131415android &#123; compileSdkVersion 27 defaultConfig &#123; ... minSdkVersion 14 targetSdkVersion 27 ... // Enabling multidex support. multiDexEnabled true &#125; ...&#125;dependencies &#123; compile 'com.android.support:multidex:1.0.3'&#125; 在代码中启动MultiDex。具体来讲，有三种方式。第一种，通过在AndroidManifest文件中指定使用MultidexApplication 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.android.multidex.myapplication"&gt; &lt;application ... android:name="android.support.multidex.MultiDexApplication"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 第二种，自定义Application并继承MultiDexApplication 123456789public class DemoApp extends MultiDexApplication &#123; @Override public void onCreate() &#123; super.onCreate(); // do nothing &#125;&#125; 第三种，自定义Application，然后在attachBaseContext方法中启用MultiDex 1234567891011121314public class BaseApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(base); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125;&#125; 其实上述三种方法最终目的都是调用MultiDex.install()这一方法。 dex包拆分dex拆包的步骤： 扫描整个工程代码，得到一个记录了标记主、从dex的main-dex-list。 根据main-dex-list，对把项目编译后的.class文件按主、从分开。 分别将主、从.class文件打包为主、从.dex文件。 生成mai-dex-list的工具在Android Sdk的Build Tools中，是一个名字叫mainDexClasses的脚本文件。其核心部分为先生成一个jar包，然后连同所有的文件一起作为参数，调用com.android.multidex.MainDexListBuilder： 1java -cp "$jarpath" com.android.multidex.MainDexListBuilder $&#123;disableKeepAnnotated&#125; "$&#123;tmpOut&#125;" $&#123;@&#125; || exit 11 MainDexListBuilder源码可以在这里查看：MainDexListBuilder.java主要做的工作就是将符合keep规则的部分加入到主dex中。因为分包之后的合包必须先执行主包再一一合包次包，因此有些必需的文件就得装在主dex包中，这里的keep规则就是为了能够将这部分文件做保护，这样在生成main-dex-list时就会默认放入主dex包中了。 dex包合并初始化根据前面MultiDex配置的方法，那么MultiDe在合并的时候就是在首次安装运行时，将从dex包逐一安装，入口就是Application中的这行代码： 1MultiDex.install(this); 在install中： 12345678910111213141516171819202122232425public static void install(Context context) &#123; Log.i("MultiDex", "Installing application"); //这里判断一下当前系统是否支持MultiDex，如果已经支持，就不用MultiDex自己合并了 if (IS_VM_MULTIDEX_CAPABLE) &#123; Log.i("MultiDex", "VM has multidex support, MultiDex support library is disabled."); &#125; else if (VERSION.SDK_INT &lt; 4) &#123;//系统版本过低 不支持 throw new RuntimeException("MultiDex installation failed. SDK " + VERSION.SDK_INT + " is unsupported. Min SDK version is " + 4 + "."); &#125; else &#123; try &#123; //获取Application对象的引用 ApplicationInfo applicationInfo = getApplicationInfo(context); if (applicationInfo == null) &#123; Log.i("MultiDex", "No ApplicationInfo available, i.e. running on a test Context: MultiDex support library is disabled."); return; &#125; //具体的安装过程 doInstallation(context, new File(applicationInfo.sourceDir), new File(applicationInfo.dataDir), "secondary-dexes", "", true); &#125; catch (Exception var2) &#123; Log.e("MultiDex", "MultiDex installation failure", var2); throw new RuntimeException("MultiDex installation failed (" + var2.getMessage() + ")."); &#125; Log.i("MultiDex", "install done"); &#125; &#125; 所以具体的安装是在doInstallation()中执行的，在调用这个方法时传入的主要参数有一个context引用，一个存放base apk的目录，一个app的data目录，一个字符串secondary-dexes作为从dex目录。 总体过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static void doInstallation(Context mainContext, File sourceApk, File dataDir, String secondaryFolderName, String prefsKeyPrefix, boolean reinstallOnPatchRecoverableException) throws IOException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException, InstantiationException &#123; //这里的installedApk是一个HashSet，应该是保存当前以及安装的dex包 Set var6 = installedApk; synchronized(installedApk) &#123; //如果souceApk不存在，就将他加入到这个HashSet中 if (!installedApk.contains(sourceApk)) &#123; installedApk.add(sourceApk); //如果编译版本大于当前支持的最大版本，就会提示 if (VERSION.SDK_INT &gt; 20) &#123; Log.w("MultiDex", "MultiDex is not guaranteed to work in SDK version " + VERSION.SDK_INT + ": SDK version higher than " + 20 + " should be backed by " + "runtime with built-in multidex capabilty but it's not the " + "case here: java.vm.version=\"" + System.getProperty("java.vm.version") + "\""); &#125; //用当前的Context获取一个ClassLoader对象的引用 ClassLoader loader; try &#123; loader = mainContext.getClassLoader(); &#125; catch (RuntimeException var25) &#123; Log.w("MultiDex", "Failure while trying to obtain Context class loader. Must be running in test mode. Skip patching.", var25); return; &#125; if (loader == null) &#123; Log.e("MultiDex", "Context class loader is null. Must be running in test mode. Skip patching."); &#125; else &#123; try &#123; //清除旧的目录 具体清除哪一个 后面再说 clearOldDexDir(mainContext); &#125; catch (Throwable var24) &#123; Log.w("MultiDex", "Something went wrong when trying to clear old MultiDex extraction, continuing without cleaning.", var24); &#125; //创造一个dex目录 File dexDir = getDexDir(mainContext, dataDir, secondaryFolderName); //创造一个MultiDexExtractor对象 MultiDexExtractor extractor = new MultiDexExtractor(sourceApk, dexDir); IOException closeException = null; try &#123; //调用MultiDexExtractor对象的load()方法，获取一个文件列表，这个文件列表应该是其他的从dex List files = extractor.load(mainContext, prefsKeyPrefix, false); try &#123; //安装这些从dex包 installSecondaryDexes(loader, dexDir, files); &#125; catch (IOException var26) &#123; if (!reinstallOnPatchRecoverableException) &#123; throw var26; &#125; //安装失败 做一次重试 Log.w("MultiDex", "Failed to install extracted secondary dex files, retrying with forced extraction", var26); files = extractor.load(mainContext, prefsKeyPrefix, true); installSecondaryDexes(loader, dexDir, files); &#125; &#125; finally &#123; try &#123; extractor.close(); &#125; catch (IOException var23) &#123; closeException = var23; &#125; &#125; if (closeException != null) &#123; throw closeException; &#125; &#125; &#125; &#125; &#125; 梳理一下，就是首先看一下sourceApk是否已经安装，如果没有则安装，然后用Context获取一个ClasLoader，清除掉旧的缓存，获取从dex包，然后用前面获取的那个ClassLoader去加载这些从dex包。然后依次来看一下那几个重要的方法。首先是clearOldDexDir(): 123456789101112131415161718192021222324252627282930313233private static void clearOldDexDir(Context context) throws Exception &#123; //获取文件目录 File dexDir = new File(context.getFilesDir(), "secondary-dexes"); if (dexDir.isDirectory()) &#123; Log.i("MultiDex", "Clearing old secondary dex dir (" + dexDir.getPath() + ")."); //获取目录下的所有子文件 File[] files = dexDir.listFiles(); if (files == null) &#123; Log.w("MultiDex", "Failed to list secondary dex dir content (" + dexDir.getPath() + ")."); return; &#125; File[] var3 = files; int var4 = files.length; //遍历所有的子文件，依次调用delete()方法删除 for(int var5 = 0; var5 &lt; var4; ++var5) &#123; File oldFile = var3[var5]; Log.i("MultiDex", "Trying to delete old file " + oldFile.getPath() + " of size " + oldFile.length()); if (!oldFile.delete()) &#123; Log.w("MultiDex", "Failed to delete old file " + oldFile.getPath()); &#125; else &#123; Log.i("MultiDex", "Deleted old file " + oldFile.getPath()); &#125; &#125; if (!dexDir.delete()) &#123; Log.w("MultiDex", "Failed to delete secondary dex dir " + dexDir.getPath()); &#125; else &#123; Log.i("MultiDex", "Deleted old secondary dex dir " + dexDir.getPath()); &#125; &#125; &#125; 所以这里是清除了/data/data//files/secondary-dexes这一目录下的所有文件。然后是getDexDir(): 12345678910111213141516private static File getDexDir(Context context, File dataDir, String secondaryFolderName) throws IOException &#123; File cache = new File(dataDir, "code_cache"); try &#123;//创建这个code_cache目录 mkdirChecked(cache); &#125; catch (IOException var5) &#123; //如果创建失败，就创建这个files/code_cache目录 cache = new File(context.getFilesDir(), "code_cache"); mkdirChecked(cache); &#125; //在刚刚创建的files/code_cache目录下再创建一个secondary-dexes目录 File dexDir = new File(cache, secondaryFolderName); mkdirChecked(dexDir); return dexDir; &#125; 总结一下，这里先创建一个/data/data//code_cache目录，如果创建失败，改为创建一个/data/data//files/code_cache目录，然后再在这一目录下创建一个secondary目录，因此总的来说创建了一个/data/data//files/code_cache/secondary-dexes或者/data/data//code_cache/secondary-dexes目录，并返回。这样也跟刚才清除目录项对应了，clear的时候清除的就是创建失败时再次创建的这一目录。再看创建一个extractor.load()： 1234567891011121314151617181920212223242526272829303132333435List&lt;? extends File&gt; load(Context context, String prefsKeyPrefix, boolean forceReload) throws IOException &#123; Log.i("MultiDex", "MultiDexExtractor.load(" + this.sourceApk.getPath() + ", " + forceReload + ", " + prefsKeyPrefix + ")"); //验证当前获取的文件锁是否有效 if (!this.cacheLock.isValid()) &#123; throw new IllegalStateException("MultiDexExtractor was closed"); &#125; else &#123; List files; //如果不是强制的重新获取 或者 未被修改 if (!forceReload &amp;&amp; !isModified(context, this.sourceApk, this.sourceCrc, prefsKeyPrefix)) &#123; try &#123; //提取之前已经存在的files files = this.loadExistingExtractions(context, prefsKeyPrefix); &#125; catch (IOException var6) &#123; Log.w("MultiDex", "Failed to reload existing extracted secondary dex files, falling back to fresh extraction", var6); //如果失败，通过performExtractions()方法获取 files = this.performExtractions(); //存储apk信息？？？ putStoredApkInfo(context, prefsKeyPrefix, getTimeStamp(this.sourceApk), this.sourceCrc, files); &#125; &#125; else &#123; //如果是强制的 或者 已经发生了修改 if (forceReload) &#123; Log.i("MultiDex", "Forced extraction must be performed."); &#125; else &#123; Log.i("MultiDex", "Detected that extraction must be performed."); &#125; //也是需要调用performExtraction()方法提取 files = this.performExtractions(); putStoredApkInfo(context, prefsKeyPrefix, getTimeStamp(this.sourceApk), this.sourceCrc, files); &#125; Log.i("MultiDex", "load found " + files.size() + " secondary dex files"); return files; &#125; &#125; 所以load()方法首先要确保当前操作获取到的文件锁是有效的，应该是为了确保多进程操作的安全。然后根据传入的参数forceReload以及是否有修改，来决定如何提取文件。如果可以，就会获取Existing文件，在此推测是缓存文件。否则，就要通过performExtractions()方法来获取并通过putStoreApkInfo()方法保存了。看看this.loadExistingExtractions()方法是否符合推测： 12345678910111213141516171819202122232425262728293031323334private List&lt;MultiDexExtractor.ExtractedDex&gt; loadExistingExtractions(Context context, String prefsKeyPrefix) throws IOException &#123; Log.i("MultiDex", "loading existing secondary dex files"); //构造一个apkName.classes为前缀 String extractedFilePrefix = this.sourceApk.getName() + ".classes"; //获取一个SP对象 SharedPreferences multiDexPreferences = getMultiDexPreferences(context); //获取总的dex数量，即totalDexNumber int totalDexNumber = multiDexPreferences.getInt(prefsKeyPrefix + "dex.number", 1); //一个存放从dex文件的list 数量为总数量-1 也就是去掉了主dex文件 List&lt;MultiDexExtractor.ExtractedDex&gt; files = new ArrayList(totalDexNumber - 1); //从第二个开始遍历，也就是跳过了第一个主dex for(int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; ++secondaryNumber) &#123; //以前缀+当前的数字+.zip为文件名,比如 xxx.classes2.zip String fileName = extractedFilePrefix + secondaryNumber + ".zip"; //获取这一文件 MultiDexExtractor.ExtractedDex extractedFile = new MultiDexExtractor.ExtractedDex(this.dexDir, fileName); if (!extractedFile.isFile()) &#123;//不存在 就会报错 throw new IOException("Missing extracted secondary dex file '" + extractedFile.getPath() + "'"); &#125; //存在 就会先做一些验证工作 extractedFile.crc = getZipCrc(extractedFile); long expectedCrc = multiDexPreferences.getLong(prefsKeyPrefix + "dex.crc." + secondaryNumber, -1L); long expectedModTime = multiDexPreferences.getLong(prefsKeyPrefix + "dex.time." + secondaryNumber, -1L); long lastModified = extractedFile.lastModified(); if (expectedModTime != lastModified || expectedCrc != extractedFile.crc) &#123; //验证不通过 会报错 throw new IOException("Invalid extracted dex: " + extractedFile + " (key \"" + prefsKeyPrefix + "\"), expected modification time: " + expectedModTime + ", modification time: " + lastModified + ", expected crc: " + expectedCrc + ", file crc: " + extractedFile.crc); &#125; //最终 验证通过 把这一文件加入到list中 files.add(extractedFile); &#125; //最后返回那个构建的从dex文件list return files; &#125; 首先获取一个SP对象，里面保存了dex文件数量相关的数据。然后通过遍历，获取所有的dex文件，加入到一个list钟返回。如果期间发现获取不到，则抛出一个异常。结合前面的代码，抛出异常后就需要通过performExtractions()方法重新提取一次： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private List&lt;MultiDexExtractor.ExtractedDex&gt; performExtractions() throws IOException &#123; //同样的，先构造一个apkName.classes的前缀 String extractedFilePrefix = this.sourceApk.getName() + ".classes"; this.clearDexDir(); List&lt;MultiDexExtractor.ExtractedDex&gt; files = new ArrayList(); //获取一个zipfile 这就是原始apk ZipFile apk = new ZipFile(this.sourceApk); try &#123; int secondaryNumber = 2; //让number从2开始累加 做一个遍历 期间的dexFile文件是apk通过classes+number+.dex为文件名获取的 for(ZipEntry dexFile = apk.getEntry("classes" + secondaryNumber + ".dex"); dexFile != null; dexFile = apk.getEntry("classes" + secondaryNumber + ".dex")) &#123; //构造一个文件名 apkName+.classes+number+.zip String fileName = extractedFilePrefix + secondaryNumber + ".zip"; //这里的dexDir就是前面创建的缓存目录 xxx/secondary-dexs，这里是用这两个参数获取到dex文件 MultiDexExtractor.ExtractedDex extractedFile = new MultiDexExtractor.ExtractedDex(this.dexDir, fileName); files.add(extractedFile); Log.i("MultiDex", "Extraction is needed for file " + extractedFile); int numAttempts = 0; boolean isExtractionSuccessful = false; //开始提取文件，不过只给了三次机会 while(numAttempts &lt; 3 &amp;&amp; !isExtractionSuccessful) &#123; ++numAttempts; //提取dex文件的核心方法 extract(apk, dexFile, extractedFile, extractedFilePrefix); try &#123; //获取crc extractedFile.crc = getZipCrc(extractedFile); isExtractionSuccessful = true; &#125; catch (IOException var18) &#123; isExtractionSuccessful = false; Log.w("MultiDex", "Failed to read crc from " + extractedFile.getAbsolutePath(), var18); &#125; Log.i("MultiDex", "Extraction " + (isExtractionSuccessful ? "succeeded" : "failed") + " '" + extractedFile.getAbsolutePath() + "': length " + extractedFile.length() + " - crc: " + extractedFile.crc); if (!isExtractionSuccessful) &#123; extractedFile.delete(); if (extractedFile.exists()) &#123; Log.w("MultiDex", "Failed to delete corrupted secondary dex '" + extractedFile.getPath() + "'"); &#125; &#125; &#125; if (!isExtractionSuccessful) &#123; throw new IOException("Could not create zip file " + extractedFile.getAbsolutePath() + " for secondary dex (" + secondaryNumber + ")"); &#125; ++secondaryNumber; &#125; &#125; finally &#123; try &#123; apk.close(); &#125; catch (IOException var17) &#123; Log.w("MultiDex", "Failed to close resource", var17); &#125; &#125; return files; &#125; 可以看到，会从2开始，不断的构造一个dex文件，然后提取这一文件到dexDir中，提取的核心方法为extract(): 123456789101112131415161718192021222324252627282930313233343536373839404142private static void extract(ZipFile apk, ZipEntry dexFile, File extractTo, String extractedFilePrefix) throws IOException, FileNotFoundException &#123; //这里的dexFile就是源dex文件 所以这里先获取了他的文件输入流 InputStream in = apk.getInputStream(dexFile); ZipOutputStream out = null; //以一个tmp文件作为交换文件 File tmp = File.createTempFile("tmp-" + extractedFilePrefix, ".zip", extractTo.getParentFile()); Log.i("MultiDex", "Extracting " + tmp.getPath()); try &#123; //压缩文件流 out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(tmp))); try &#123; ZipEntry classesDex = new ZipEntry("classes.dex"); classesDex.setTime(dexFile.getTime()); out.putNextEntry(classesDex); byte[] buffer = new byte[16384]; //文件写入的过程 for(int length = in.read(buffer); length != -1; length = in.read(buffer)) &#123; out.write(buffer, 0, length); &#125; out.closeEntry(); &#125; finally &#123; out.close(); &#125; if (!tmp.setReadOnly()) &#123; throw new IOException("Failed to mark readonly \"" + tmp.getAbsolutePath() + "\" (tmp of \"" + extractTo.getAbsolutePath() + "\")"); &#125; Log.i("MultiDex", "Renaming to " + extractTo.getPath()); //将交换文件转换为目标文件，即secondary-dexs目录下的相对应的文件 if (!tmp.renameTo(extractTo)) &#123; throw new IOException("Failed to rename \"" + tmp.getAbsolutePath() + "\" to \"" + extractTo.getAbsolutePath() + "\""); &#125; &#125; finally &#123; closeQuietly(in); tmp.delete(); &#125; &#125; 具体的提取过程到这里就结束了，总结一下，就是通过load()方法，将源dex文件一一写入到新的secondary-dexs目录下对应的文件中，这一过程会将源apk文件进行一个解压，且只会从第二个dex文件开始，因为第一个就是主dex文件，主dex是已经安装好了的。 install具体过程好了，现在所有的次dex包都已经提取出来，接下来就是安装了，安装的入口就是前面的installSecondaryDexes()方法： 123456789101112private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;? extends File&gt; files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException, SecurityException, ClassNotFoundException, InstantiationException &#123; if (!files.isEmpty()) &#123; if (VERSION.SDK_INT &gt;= 19) &#123; MultiDex.V19.install(loader, files, dexDir); &#125; else if (VERSION.SDK_INT &gt;= 14) &#123; MultiDex.V14.install(loader, files); &#125; else &#123; MultiDex.V4.install(loader, files); &#125; &#125; &#125; 安装dex包时，会根据不同的sdk版本有不同的方法。就以sdk&gt;=19举例，他的install()方法如下： 12345678910111213141516171819202122232425262728293031323334static void install(ClassLoader loader, List&lt;? extends File&gt; additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123; //通过反射 获取ClassLoader 的 pathList 字段 Field pathListField = MultiDex.findField(loader, "pathList"); Object dexPathList = pathListField.get(loader); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList(); //先调用makeDexElements方法 把从Dex文件们变成Element对象 //然后调用expandFieldArray方法 把刚才得到的Element对象们添加到dexPathList的dexElements字段的后面(这个字段是个数组) MultiDex.expandFieldArray(dexPathList, "dexElements", makeDexElements(dexPathList, new ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); //添加一些IO异常信息 if (suppressedExceptions.size() &gt; 0) &#123; Iterator var6 = suppressedExceptions.iterator(); while(var6.hasNext()) &#123; IOException e = (IOException)var6.next(); Log.w("MultiDex", "Exception in makeDexElement", e); &#125; Field suppressedExceptionsField = MultiDex.findField(dexPathList, "dexElementsSuppressedExceptions"); IOException[] dexElementsSuppressedExceptions = (IOException[])((IOException[])suppressedExceptionsField.get(dexPathList)); if (dexElementsSuppressedExceptions == null) &#123; dexElementsSuppressedExceptions = (IOException[])suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); &#125; else &#123; IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; &#125; suppressedExceptionsField.set(dexPathList, dexElementsSuppressedExceptions); IOException exception = new IOException("I/O exception during makeDexElement"); exception.initCause((Throwable)suppressedExceptions.get(0)); throw exception; &#125; &#125; 在install中，主要就是通过反射机制，从ClassLoader中获取一个叫做pathlist的Field，再将dex包们通过makeElements()方法产生一个Element数组，然后调用expandFieldArray()方法，按字面意思应该是对数组进行了扩展。最后，查看是否有异常需要抛出。 在Android中，类加载器有两种，DexClassLoader和PathClassLoader，这两个加载器都是继承自BaseClassLoader的。pathlist就是定义在BaseClassLoader中的： 12345678/** * Base class for common functionality between various dex-based * &#123;@link ClassLoader&#125; implementations. */public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList;&#125; 再看看这个DexPathList具体是什么： 123456789101112131415/** * A pair of lists of entries, associated with a &#123;@code ClassLoader&#125;. * One of the lists is a dex/resource path &amp;mdash; typically referred * to as a "class path" &amp;mdash; list, and the other names directories * containing native code libraries. Class path entries may be any of: * a &#123;@code .jar&#125; or &#123;@code .zip&#125; file containing an optional * top-level &#123;@code classes.dex&#125; file as well as arbitrary resources, * or a plain &#123;@code .dex&#125; file (with no possibility of associated * resources). * * &lt;p&gt;This class also contains methods to use these lists to look up * classes and resources.&lt;/p&gt; *//*package*/ final class DexPathList &#123;&#125; 所以他相当于是封装了一个存放dex路径的list。回到install方法中，按步骤看一下。首先是makeElements(): 12345678910111213141516/** * A wrapper around * &#123;@code private static final dalvik.system.DexPathList#makeDexElements&#125;. */private static Object[] makeDexElements( Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Method makeDexElements = findMethod(dexPathList, "makeDexElements", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);&#125; 看注释就知道，这里也是通过反射，调用了前面DexPathList的makeDexElements()方法，那就来看看吧： 123456789/** * Makes an array of dex/resource path elements, one per element of * the given array. */private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123; return makeElements(files, optimizedDirectory, suppressedExceptions, false, loader);&#125; 创建了一个dex/resource的数组： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private static Element[] makeElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, boolean ignoreDexFiles, ClassLoader loader) &#123; //创建一个Element数组 Element[] elements = new Element[files.size()]; int elementsPos = 0; /* * Open all files and load the (direct or contained) dex files * up front. */ //遍历 打开所有的文件 for (File file : files) &#123; File zip = null; File dir = new File(""); DexFile dex = null; String path = file.getPath(); String name = file.getName(); //这个zipSeparator的值为 !/ if (path.contains(zipSeparator)) &#123; String split[] = path.split(zipSeparator, 2); zip = new File(split[0]); dir = new File(split[1]); &#125; else if (file.isDirectory()) &#123; // We support directories for looking up resources and native libraries. // Looking up resources in directories is useful for running libcore tests. elements[elementsPos++] = new Element(file, true, null, null); &#125; else if (file.isFile()) &#123; //根据前面的源码 这里的ignoreDexFiles为false，而DEX_SUFFIX的值为 .dex if (!ignoreDexFiles &amp;&amp; name.endsWith(DEX_SUFFIX)) &#123; // Raw dex file (not inside a zip/jar). try &#123; //找到了dex文件，尝试加载 dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123; System.logE("Unable to load dex file: " + file, suppressed); suppressedExceptions.add(suppressed); &#125; &#125; else &#123; zip = file; if (!ignoreDexFiles) &#123; try &#123; dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123; /* * IOException might get thrown "legitimately" by the DexFile constructor if * the zip file turns out to be resource-only (that is, no classes.dex file * in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); &#125; &#125; &#125; &#125; else &#123; System.logW("ClassLoader referenced unknown path: " + file); &#125; //加载完毕 将获取到的zip或者dex先封装为一个Element对象，再将这个Element对象放入前面的Element数组中 if ((zip != null) || (dex != null)) &#123; elements[elementsPos++] = new Element(dir, false, zip, dex); &#125; &#125; if (elementsPos != elements.length) &#123; elements = Arrays.copyOf(elements, elementsPos); &#125; return elements;&#125; 然后是expandFieldArray()方法： 123456789101112131415161718/** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. */private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined);&#125; 结合注释就知道，这里是用一个包含了原来的elements的新的数组，加入了新的elemets。这里也是反射，实际发生了变化的是DexPathList的数组： 123456/** * List of dex/resource (class path) elements. * Should be called pathElements, but the Facebook app uses reflection * to modify 'dexElements' (http://b/7726934). */ private Element[] dexElements; 总结一下，具体的安装过程就是将Dex包们封装为Element对象，再将这些Element对象插入到原来的Element数组中，充当为新的数组，而这整个过程都是通过反射来做的，具体的执行者就是DexPathList 总结上面都是一些工具方法，主要用途就是通过反射，获取对象，调用指定方法。dex合并就到这里了，总结一下合并的步骤： 检查当前系统能够自动合并包，以及如果不支持的话系统版本是否支持multidex。 清除旧的备用缓存目录，之所以叫备用是因为在创建目录时创建失败才会创建备用目录，这个备用目录是需要删除的。 创建新的缓存目录，然后提取从dex文件至缓存目录中。 安装缓存目录中断dex文件，这时根据当前系统的版本有不同的安装方法，但大体上逻辑是一样的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MultiDex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android打包相关知识整理（一）]]></title>
    <url>%2F2018%2F10%2F29%2Fandroid-pack-app-1%2F</url>
    <content type="text"><![CDATA[一些基础概念JVM Dalvik ARTJVM &amp; DVMDVM，即Dalvik，是Google开发的用于Android平台的Java虚拟机，JVM则是传统的Java虚拟机，有很多具体的版本，是跨平台的。那么他们的区别主要体现在以下几点： 从架构上看，JVM是基于栈的，DVM是基于寄存器的。 JVM执行的是由Java文件编译的.class文件，而DVM则执行的是有Java文件编译为.class文件后，再次编译得到的.dex文件。 JVM只能运行一个实例，若干应用程序都在同一个虚拟机中。而DVM则可以运行多个虚拟机实例，每一个app都运行在单独的虚拟机进程中。DVM &amp; ARTART，即Android Runtime，也算是Dalvik虚拟机的升级版。从Android 4.4版本开始，系统就已经内置了ART，直到5.0开始，完全用ART替换了Dalvik。Dalvik安装的app，在运行时会动态的将一部分字节码解释为机器码，这一过程是即时编译，JIT(Just in time)，而ART则是在一开始安装app时就将字节码转换为了机器码并存在存储相应的存储空间，这一过程是提前编译，AOT(Ahead of time)。因此，DVM下app运行较慢，且会频繁的访问cpu,而ART下app虽然安装时间更长且占用了更多的空间，但是启动、运行速度有了提升，节省了电量的消耗。JIT &amp; AOT前面提到了JIT和AOT只是两种不同的编译形式，一种是即使编译，一种是提前编译。JIT是从Android 2.2引入的。虚拟机执行的是字节码DEX，但是机器执行的是机器码，因此每次运行程序的时候，都需要将DEX转换为本地的机器码，交给机器执行。加入JIT后，这一过程就由JIT来处理了。具体来讲，就是在程序运行中，每遇到一个新类，就会对这个类进行编译，编译后的结果转换为精简的原生指令码，这样下次执行到同样的逻辑时，直接执行这一精简原生指令码，就会提高运行速度了。但是如果对所有的类都进行JIT，那么那些执行次数较少的类就会拖慢整体的速度，因为你转换毕竟也是需要时间的嘛。所以并不是对所有代码都执行JIT的，是有选择的。此外，JIT并不是一劳永逸的，在每次运行时，都要重新进行JIT。AOT相对来说，则是“用空间换时间”。在第一次安装时，就已经将字节码转换为了机器码，并保存在特定的存储空间。这样会导师安装时较慢，且会占用额外的存储空间，但是好处也是很明显的，程序运行时直接执行机器码即可，运行速度有了提升。无论是JIT还是AOT，各有优缺点。所以Google在Android 7.0上将JIT和AOT合并起来一起用。具体来说，应用在初次安装时，不会提前编译了，因此安装速度不会降低。在应用运行时，会通过JIT优化，存储在jit code cache中，同时标记执行次数较多的函数并记录在profile文件中。等手机进入charging和idle状态时，系统会每隔一段时间扫描这些profile文件，执行AOT。以为只优化了那些热点函数，因此在初次运行时没有很明显的变化，在多次运行后，才会有速度的显著提升。同时所占用的额外存储空间也小了，安装速度也提高了。DEX ODEX OATJVM执行的是由类文件编译出的.class文件，而Android虚拟机，执行的是由.class文件进一步处理得到的文件，这一处理过程即dx，得到的文件为.dex文件。所以DEX文件简单来说就是有.class文件通过dx工具转化的。一般情况下，一个项目中有很多类文件，会生成很多.class文件，这些多个.class文件会通过文件内容的优化，然后合并，最终得到一个.dex文件（在不考虑64k这种特殊情况下）。ODEX文件，即Optimized dex，是DEX经过优化后得到的文件。他并不是一种文件格式，即不存在什么.odex后缀，他只是一种类型，即DEX文件经过优化后的文件类型。那么具体来说，一个.dex文件在经过优化后，后缀可能还是.dex，也可能变成了新的.oat，但是他们都还是属于ODEX文件——优化后的DEX文件。具体来讲，我们app打包成apk后，apk作为一种压缩文件，内部包含了DEX文件。在系统首次开机时，会解压apk文件，取出其中的DEX文件，存储到系统的data/app目录下。然后，重点来了，如果当前运行的是Dalvik虚拟机，那么DEX文件会被Dalvik虚拟机进行一次优化，这次优化是通过函数dexopt执行的，优化产生的文件名还是旧的文件名，后缀还是.dex，只是他现在已经不是DEX文件，而是优化的DEX文件，也就是ODEX文件了。而如果当前系统运行的虚拟机是ART，那么DEX文件也会被ART虚拟机做一次优化，这次优化是通过dex2oat工具执行的，优化后生成的文件名还是旧的文件名，后缀变成了.oat，文件类型也变成了ODEX。两种优化方式最终都会将ODEX文件存放至系统的data/dalvik-cache目录下。为什么要这样处理文件名呢？因为虚拟机是从Dalvik过渡到ART上的，这样的优化后文件名不变，路径，那么任何通过绝对路径来引用ODEX文件的代码就都不用修改了。 apkapk的内容分析打包过程，首先看一下打包后的结果，然后逆推每一部分是如何打包的。apk全称是Android Package，其实就是一个后缀为.apk的压缩文件，他包含了Android App包含的代码、资源的所有数据。用解压工具解压一个apk包后，可以看到目录如下： AndroidManifest.xml这一文件是Android应用程序的清单文件，我们平时写应用时都会和他打交道。这一文件内包含了应用程序的所有界面、权限、BroadCast等内容，以及程序自己的相关信息，这个文件相当于是应用程序用来给系统做一个自我介绍。 assets这一目录存放了apk中的静态资源文件，需要通过AssetManager类来访问内容。 classes.dexAndroid项目中的代码在编译后会生成.class文件，然后再通过dx工具转换为字节码文件，就是这个dex文件。一般情况下只有一个classes.dex，如果项目代码方法数超过了65535而采用了multidex的话，会有其他的.dex文件。 META-INF这以目录包含了应用程序的签名信息，用来验证apk文件的完整性、合法性，帮助系统在安装应用程序时能够确保apk文件是完整、安全的，没有被破坏、修改。 res这一目录下存放了所有的其他资源，包括像layout资源、drawable资源等，这些资源都映射到一个个资源ID，应用程序则通过资源的索引来访问这些资源文件。 resources.arsc资源的索引，是通过资源ID来做的。这里的resources.arsc是一个资源索引表，相当于记录了资源文件路径与其对应的ID的一个表，而R.java文件，则定义了资源关联的ID。在程序中通过R文件定义的资源名称，获取资源ID，进而用资源ID在resources.arsc中获取到资源的具体路径。 apk打包流程这是最新的官网的打包流程图：这是旧版官网的打包流程图：相对而已，旧版的更加详细一点。就拿旧版的打包流程图来说吧，打包主要有以下几步： 使用aapt工具处理所有的资源，生成一个R.java文件，一个resources.arsc文件以及其他资源。 处理.aidl文件，生成对应的Java接口文件。 将上述两步得到的R.java文件、Java接口文件，与Andorid源码一起，通过Java编译器，编译得到Java字节码文件.class文件。 获取依赖的第三方库文件，将其与上一步得到的.class文件一起，通过使用dx工具，生成.dex文件。 将资源索引文件resources.arsc、资源目录res、与上一步得到的.dex文件一起，通过apkbuilder工具，构建出初始的.apk文件。 使用jarsigner工具，对.apk文件进行签名。 使用zipalign工具，对.apk文件进行对齐。（让资源按四字节的边界进行对齐，加快资源的访问速度） 经过以上七步，一个完成的apk文件就诞生了。 apk安装过程Android应用的安装涉及到以下几个目录： /data/app：存放apk文件 /data/data：存放应用程序的数据 /data/dalvik-cache：存放ODEX文件 具体的安装过程如下： 将apk文件复制到系统的/data/app目录下。 解压apk文件。 通过apk文件中的签名文件，校验签名，验证apk包的合法、安全性。 解压并校验.dex文件。 将解压得到的.dex文件进行优化，产生odex文件，存储在/data/dalvik-cache目录下。 在/data/data目录下，以应用程序的包名为名，创建一个目录，用来存储应用程序的所有数据。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MultiDex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018学习计划]]></title>
    <url>%2F2018%2F10%2F25%2Fhello%2F</url>
    <content type="text"><![CDATA[要看哪些书 《Effective Java》 《计算机网路》 《深入理解计算机系统》 《Android Gradle》 《Android源码设计模式解析与实战》（复习） 《经济学原理-微观经济学》要掌握哪些东西 Handler通信机制 Activity生命周期函数的执行 Activity启动流程 Activity setContent() AIDL Android打包相关内容 multidex原理 hencooder自定义View教程 View绘制流程 View事件分发 android动画 RecyclerView源码 Retrofit源码 Glide源码想做点什么 设计一个app Artifact Helper! 写一个用来决定吃什么的app]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Activity的绘制]]></title>
    <url>%2F2017%2F11%2F28%2Fsource-activity-setcontent-%2F</url>
    <content type="text"><![CDATA[Activity 的setContent()流程以前的Activity，都是直接继承Activity.java，而现在的Activity则基本都是继承AppCompatActivity.java，自然setContent()是不一样的，那么先捋一捋旧的 Activity.java先从Activity.java开始看起。 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; 可以看到，getWindow()方法获取了一个自己Activity持有的Window对象的引用，再调用这个对象的setContent()，之后做一个初始化流程。Window类是一个抽象类： 12345678910/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */ 看注释，这大概是一个Activity所呈现界面的顶层Window。他的实现类只有一个，是PhoneWindow。那么就来看看这个PhoneWindow类的setContentView()方法实现： 12345678910111213141516171819202122232425262728@Overridepublic void setContentView(int layoutResID) &#123; //首先这里有一个ContentParent，如果为空则做一个初始化 if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; //根据是否需要动画来做一些事 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; /* 不需要动画，直接开始加载布局，这里是将layoutResID布局加载到了mContentParent上 而layoutResID是我们交给setContent(）的那个布局id 因此我们的Activity最终显示的页面就是加载 到了mContent上 */ mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 再看看mContentParent的定义： 1234// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.ViewGroup mContentParent; 可以看到，这个mContentParent其实就是一个ViewGroup 所以在setContent()中主要做了两件事： 初始化一个Window持有的ContentParent（即ViewGroup）对象 将布局文件加载到ContentParent上那么现在看看这个所谓的初始化过程做了什么，即installDecor(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123;//第一步，发现mDecor没有初始化 //生成一个mDecor对象，并对其初始化 mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; //让mDecor获取一个当前window的引用 mDecor.setWindow(this); &#125; if (mContentParent == null) &#123;//第二步，发现mContentParent没有初始化 //用前面的mDecor生成一个mContentParent对象并初始化 mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); //在mDecor中找一下是否有一个DecorContentParent final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); //有？对这个做初始化 if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); //………… &#125; else &#123;//没有？那么从这里开始 //获取一个作为title的view并初始化 mTitleView = findViewById(R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; final View titleContainer = findViewById(R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; mContentParent.setForeground(null); &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; //对这个mDecor设置背景（回调） if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; //之后就是一些无关紧要的东西了 &#125; 再看看这个mDecor是何方神圣： 12// This is the top-level view of the window, containing the window decor. private DecorView mDecor; 1234** @hide */public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; //…………&#125; 原来mDecor就是一个FrameLayout了。那么这个初始化过程就分为了两步： 初始化mDecor(一个FrameLayout) 借助mDecor初始化mContentParent 再来分别看看两者是如何初始化的，显示mDecor: 1234567891011121314151617181920protected DecorView generateDecor(int featureId) &#123; // System process doesn't have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don't cling to the // activity. Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext().getResources()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; return new DecorView(context, featureId, this, getAttributes()); &#125; 先是用想办法和获取一个context，然后再调用新的构造器，这里的featureId传进来的是-1。然后看构造器： 1234567891011121314151617181920212223242526272829DecorView(Context context, int featureId, PhoneWindow window, WindowManager.LayoutParams params) &#123; super(context); mFeatureId = featureId; mShowInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.linear_out_slow_in); mHideInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.fast_out_linear_in); mBarEnterExitDuration = context.getResources().getInteger( R.integer.dock_enter_exit_duration); mForceWindowDrawsStatusBarBackground = context.getResources().getBoolean( R.bool.config_forceWindowDrawsStatusBarBackground) &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= N; mSemiTransparentStatusBarColor = context.getResources().getColor( R.color.system_bar_background_semi_transparent, null /* theme */); updateAvailableWidth(); //前面不是有一个在发现mDecorView不为Null时要赋予一个当前window引用吗？这里就是在初始化完成后再做的 setWindow(window); updateLogTag(params); mResizeShadowSize = context.getResources().getDimensionPixelSize( R.dimen.resize_shadow_size); initResizingPaints(); &#125; 至此一个DecorView就初始化完成了，他实际上是一个FrameLayout。接下来看看这个mContentParent是如何通过DecorView来生成的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. //这里先拿到一些属性 TypedArray a = getWindowStyle(); //………… //这里开始先是对每一种属性做判断了，比如是否悬浮？是否无标题？等等 //具体方法和我们写自定义View时是一样的，这里省略了 mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT); setFlags(0, flagsToUpdate); &#125; else &#123; setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; //……………… //这里开始取出部分app相关的信息，比如targetsdk final Context context = getContext(); final int targetSdk = context.getApplicationInfo().targetSdkVersion; //……………… WindowManager.LayoutParams params = getAttributes(); //这里是和高端设备相关的设置 // Non-floating windows on high end devices must put up decor beneath the system bars and // therefore must know about visibility changes of those. if (!mIsFloating &amp;&amp; ActivityManager.isHighEndGfx()) &#123; if (!targetPreL &amp;&amp; a.getBoolean( R.styleable.Window_windowDrawsSystemBarBackgrounds, false)) &#123; setFlags(FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS &amp; ~getForcedWindowFlags()); &#125; if (mDecor.mForceWindowDrawsStatusBarBackground) &#123; params.privateFlags |= PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND; &#125; &#125; //……………… if (params.windowAnimations == 0) &#123; params.windowAnimations = a.getResourceId( R.styleable.Window_windowAnimationStyle, 0); &#125; // The rest are only done if this window is not embedded; otherwise, // the values are inherited from our container. if (getContainer() == null) &#123; if (mBackgroundDrawable == null) &#123; if (mBackgroundResource == 0) &#123; mBackgroundResource = a.getResourceId( R.styleable.Window_windowBackground, 0); &#125; if (mFrameResource == 0) &#123; mFrameResource = a.getResourceId(R.styleable.Window_windowFrame, 0); &#125; mBackgroundFallbackResource = a.getResourceId( R.styleable.Window_windowBackgroundFallback, 0); if (false) &#123; System.out.println("Background: " + Integer.toHexString(mBackgroundResource) + " Frame: " + Integer.toHexString(mFrameResource)); &#125; &#125; if (mLoadElevation) &#123; mElevation = a.getDimension(R.styleable.Window_windowElevation, 0); &#125; mClipToOutline = a.getBoolean(R.styleable.Window_windowClipToOutline, false); mTextColor = a.getColor(R.styleable.Window_textColor, Color.TRANSPARENT); &#125; // Inflate the window decor. //这里开始，就来真的了 //这个int值代表了要加载的布局的id int layoutResource; //所需的属性 int features = getLocalFeatures(); //然后，根据属性不同的需求，获取不同的布局文件id // System.out.println("Features: 0x" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println("Title Icons!"); //中间忽略，直接看最简单的一种布局 &#125; else &#123; // Embedded, so no decoration is needed. //记住这个布局文件id layoutResource = R.layout.screen_simple; // System.out.println("Simple!"); &#125; //标识着这个decorview开始改变了 mDecor.startChanging(); //将刚才那个布局文件，加载到decor中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //通过findviewbyid()的方式获取这个contentParent，记住这个ID_ANDROID_CONTENT ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); //……………… // Remaining setup -- of background and title -- that only applies // to top-level windows. //初始化背景和标题等等一些属性 if (getContainer() == null) &#123; final Drawable background; if (mBackgroundResource != 0) &#123; background = getContext().getDrawable(mBackgroundResource); &#125; else &#123; background = mBackgroundDrawable; &#125; //为decorview设置背景 mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) &#123; frame = getContext().getDrawable(mFrameResource); &#125; else &#123; frame = null; &#125; mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) &#123; setTitle(mTitle); &#125; if (mTitleColor == 0) &#123; mTitleColor = mTextColor; &#125; setTitleColor(mTitleColor); &#125; //标识着改变结束 mDecor.finishChanging(); //最后，返回这个contentParent return contentParent; &#125; 总结一下，就是给这个framelayout————DecorView设置了一种布局，然后通过findviewbyid的方式获取一个contentparent的。那么这两者有什么关系呢？观察到前面提到了两个id，联系就在这里！所以接下来看看具体设置布局的逻辑。 首先看看加载布局： 12345678910111213141516171819202122232425262728void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; mStackId = getStackId(); if (mBackdropFrameRenderer != null) &#123; loadBackgroundDrawablesIfNeeded(); mBackdropFrameRenderer.onResourcesLoaded( this, mResizingBackgroundDrawable, mCaptionBackgroundDrawable, mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState), getCurrentColor(mNavigationColorViewState)); &#125; mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root; initializeElevation(); &#125; 看到layoutInflater就知道了，这里果然是加载layoutResource指向的那个布局，这里加载后为一个叫做root的View，然后通过调用addView()方法————我们知道DecorView本身是一个FrameLayout————将root加载到自己这个FrameLayout中。 接下来看看layoutResource所引用的布局R.layout.screen_simple，即screen_simple.xml的内容： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 嗯，一个LinearLayout，包含了一个ViewStub占位和一个FrameLayout。做一个猜测，这就是我们Activity最普通的初始界面，即一个状态栏+一个主界面。然后发现下面那个FrameLayout的id是content，再回到刚才方法中，通过findviewbyid初始化找到contentParent的时候用的id是哪个？ 1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 根据注释，我们知道了，这个id引用的view就是我们的主布局要加载的地方，也就是在刚才那个xml文件中的FrameLayout！ 到此为止，一个installDecor()的过程基本完成了，来捋一捋。 首先要初始化一个叫做DecorView的FrameLayout，他是和当前Window息息相关的。我们知道一个Activity，他的显示界面这个模块是交给了Window管理，而在Window中则是交给了DeocrView。这个DecorView会根据不同的需求（主题）来给自己填上一个不同的布局。然后在加载进来的这个布局中，有一个ViewGroup是专门用来显示我们编写的界面的，这个ViewGroup会通过findViewById()的形式在DecorView中找到，然后交给mContentParent，这样我们要将自己写的布局加载进来的时候，就是直接加载到mContentParent中就可以了。 回过头来看看setContentView： 123456789101112131415161718192021222324252627@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //这里可以看到，前面初始化结束后，果然是将我们自己写的布局加载到了mContentParent中！ mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125; 至此，Activity的setContent()流程就是走完了，大致知道了布局是怎么加载进来的。接下来看看新的AppCompatActivity是如何加载布局的 AppCompatActivity接下来再看看AppCompatActivity是如何加载布局的先看AppCompatActivity.java的setContentView()方法： 12345@Override public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID); &#125; 这里通过getDelegate()方法获取了一个对象的引用，再调用他的setContentView()方法，相当于做了一个代理。那么现在问题拆分为两步： 代理的对象是如何创建的 代理对象的setContentView()是如何执行的 先看第一个问题： 1234567891011/** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125; 这里用来做代理的，是一个AppCompatDelegate对象，叫mDelegate，他是通过一个静态方法create()创建的，那么先看看这个类是什么： 123&lt;p&gt;An &#123;@link Activity&#125; can only be linked with one &#123;@link AppCompatDelegate&#125; instance,* therefore the instance returned from &#123;@link #create(Activity, AppCompatCallback)&#125; should be* retained until the Activity is destroyed.&lt;/p&gt; 再来看看他的create()方法： 12345678/** * Create a &#123;@link android.support.v7.app.AppCompatDelegate&#125; to use with &#123;@code activity&#125;. * * @param callback An optional callback for AppCompat specific events */ public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback); &#125; 123456789101112131415private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (BuildCompat.isAtLeastN()) &#123; return new AppCompatDelegateImplN(context, window, callback); &#125; else if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV9(context, window, callback); &#125; &#125; 可以看到，这里最终是根据不同的sdk版本来创建不同的AppCompatDelegateImplxxx对象，分别点进去看看后会发现，最终都是到了AppCompatDelegateImplV9.java，然后： 1class AppCompatDelegateImplV9 extends AppCompatDelegateImplBase 123AppCompatDelegateImplV9(Context context, Window window, AppCompatCallback callback) &#123; super(context, window, callback); &#125; 所以最终是调用了父类的构造器： 12345678910111213141516171819202122AppCompatDelegateImplBase(Context context, Window window, AppCompatCallback callback) &#123; mContext = context; mWindow = window; mAppCompatCallback = callback; mOriginalWindowCallback = mWindow.getCallback(); if (mOriginalWindowCallback instanceof AppCompatWindowCallbackBase) &#123; throw new IllegalStateException( "AppCompat has already installed itself into the Window"); &#125; mAppCompatWindowCallback = wrapWindowCallback(mOriginalWindowCallback); // Now install the new callback mWindow.setCallback(mAppCompatWindowCallback); final TintTypedArray a = TintTypedArray.obtainStyledAttributes( context, null, sWindowBackgroundStyleable); final Drawable winBg = a.getDrawableIfKnown(0); if (winBg != null) &#123; mWindow.setBackgroundDrawable(winBg); &#125; a.recycle(); &#125; 这样就完成了。接下来看看setContentView()是如何执行的。进入AppCompatDelegateImplV9.java的setContentView(): 123456789101112@Override public void setContentView(int resId) &#123; //确保创建一个SubDecor ensureSubDecor(); //通过findviewbyid的方式找到android.R.id.contentd代表的view，作为一个contentParent ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); //清空 contentParent.removeAllViews(); //将我们自己的布局文件加载到这个contentParent中 LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged(); &#125; 再看看这个SubDecor是什么： 1234// true if we have installed a window sub-decor layout. private boolean mSubDecorInstalled; private ViewGroup mSubDecor; 所以我们自己写的布局文件最终是被加载到了一个id为content的ViewGroup上，而这个ViewGroup是通过subDecor来找到的，而这个SubDecor也是一个ViewGroup。那么重点就是ensureSubDecor()了，他的作用应该就是初始化一个SubDecor了： 12345678910111213141516171819202122232425262728private void ensureSubDecor() &#123; if (!mSubDecorInstalled) &#123; //创建一个SubDecor mSubDecor = createSubDecor(); // If a title was set before we installed the decor, propagate it now CharSequence title = getTitle(); if (!TextUtils.isEmpty(title)) &#123; onTitleChanged(title); &#125; applyFixedSizeWindow(); //做一个install？ onSubDecorInstalled(mSubDecor); //标识已经installed mSubDecorInstalled = true; // Invalidate if the panel menu hasn't been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null)) &#123; invalidatePanelMenu(FEATURE_SUPPORT_ACTION_BAR); &#125; &#125; &#125; 现在就分为了两步： mSubDecor是如何被创建的 创建成功之后做了什么 第一个问题，看createSubDecor()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192private ViewGroup createSubDecor() &#123; //和自定义View时获取属性类似，这儿是从AppCompatTheme获取了属性 TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); //这里判断如果没有加这个属性的话会抛出异常 if (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123; a.recycle(); throw new IllegalStateException( "You need to use a Theme.AppCompat theme (or descendant) with this activity."); &#125; //接下来就是普通的挨个遍历属性了 if (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, false)) &#123; requestWindowFeature(Window.FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR); &#125; if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, false)) &#123; requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); &#125; if (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, false)) &#123; requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY); &#125; mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, false); a.recycle(); // Now let's make sure that the Window has installed its decor by retrieving it //这里通过Window对象（即PhoneWindow）调用了getDecorView()方法，猜测是获取Decor //这里是重点，待会儿分析 mWindow.getDecorView(); final LayoutInflater inflater = LayoutInflater.from(mContext); //创建了一个subDecor引用，还未实例化 ViewGroup subDecor = null; //根据不同需求，让subDecor 装载不同的布局 if (!mWindowNoTitle) &#123; if (mIsFloating) &#123; // If we're floating, inflate the dialog title decor subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); // Floating windows can never have an action bar, reset the flags mHasActionBar = mOverlayActionBar = false; &#125; else if (mHasActionBar) &#123; /** * This needs some explanation. As we can not use the android:theme attribute * pre-L, we emulate it by manually creating a LayoutInflater using a * ContextThemeWrapper pointing to actionBarTheme. */ TypedValue outValue = new TypedValue(); mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, true); Context themedContext; if (outValue.resourceId != 0) &#123; themedContext = new ContextThemeWrapper(mContext, outValue.resourceId); &#125; else &#123; themedContext = mContext; &#125; // Now inflate the view using the themed context and set it as the content view subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); mDecorContentParent = (DecorContentParent) subDecor .findViewById(R.id.decor_content_parent); mDecorContentParent.setWindowCallback(getWindowCallback()); /** * Propagate features to DecorContentParent */ if (mOverlayActionBar) &#123; mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); &#125; if (mFeatureProgress) &#123; mDecorContentParent.initFeature(Window.FEATURE_PROGRESS); &#125; if (mFeatureIndeterminateProgress) &#123; mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS); &#125; &#125; &#125; else &#123; if (mOverlayActionMode) &#123; subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); &#125; else &#123; subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); &#125; if (Build.VERSION.SDK_INT &gt;= 21) &#123; // If we're running on L or above, we can rely on ViewCompat's // setOnApplyWindowInsetsListener ViewCompat.setOnApplyWindowInsetsListener(subDecor, new OnApplyWindowInsetsListener() &#123; @Override public WindowInsetsCompat onApplyWindowInsets(View v, WindowInsetsCompat insets) &#123; final int top = insets.getSystemWindowInsetTop(); final int newTop = updateStatusGuard(top); if (top != newTop) &#123; insets = insets.replaceSystemWindowInsets( insets.getSystemWindowInsetLeft(), newTop, insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom()); &#125; // Now apply the insets on our view return ViewCompat.onApplyWindowInsets(v, insets); &#125; &#125;); &#125; else &#123; // Else, we need to use our own FitWindowsViewGroup handling ((FitWindowsViewGroup) subDecor).setOnFitSystemWindowsListener( new FitWindowsViewGroup.OnFitSystemWindowsListener() &#123; @Override public void onFitSystemWindows(Rect insets) &#123; insets.top = updateStatusGuard(insets.top); &#125; &#125;); &#125; &#125; //到此为止，subDecor算是实例化完毕了 if (subDecor == null) &#123; throw new IllegalArgumentException( "AppCompat does not support the current theme features: &#123; " + "windowActionBar: " + mHasActionBar + ", windowActionBarOverlay: "+ mOverlayActionBar + ", android:windowIsFloating: " + mIsFloating + ", windowActionModeOverlay: " + mOverlayActionMode + ", windowNoTitle: " + mWindowNoTitle + " &#125;"); &#125; if (mDecorContentParent == null) &#123; mTitleView = (TextView) subDecor.findViewById(R.id.title); &#125; // Make the decor optionally fit system windows, like the window's decor ViewUtils.makeOptionalFitsSystemWindows(subDecor); //这里开始重点来了 //从subDecor中拿到了一个ContentFrameLayout,注意id为R.id.action_bar_activity_content final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById( R.id.action_bar_activity_content); //从window中拿到一个id为content的ViewGroup final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content); if (windowContentView != null) &#123; // There might be Views already added to the Window's content view so we need to // migrate them to our content view // 这里，依次从window中那个viewgroup中取出子View //然后将他们放入那个从subDecor中拿到的Content中 while (windowContentView.getChildCount() &gt; 0) &#123; final View child = windowContentView.getChildAt(0); windowContentView.removeViewAt(0); contentView.addView(child); &#125; // Change our content FrameLayout to use the android.R.id.content id. // Useful for fragments. //全部挪完之后，给原来window中的那个ViewGroup把id值为NO_ID windowContentView.setId(View.NO_ID); //然后偷梁换柱，把那个ContentFrameLayout的id设为了content contentView.setId(android.R.id.content); // The decorContent may have a foreground drawable set (windowContentOverlay). // Remove this as we handle it ourselves //把那个背景也去掉了 if (windowContentView instanceof FrameLayout) &#123; ((FrameLayout) windowContentView).setForeground(null); &#125; &#125; // Now set the Window's content view with the decor //狸猫换太子，直接把subDecor给了Window mWindow.setContentView(subDecor); contentView.setAttachListener(new ContentFrameLayout.OnAttachListener() &#123; @Override public void onAttachedFromWindow() &#123;&#125; @Override public void onDetachedFromWindow() &#123; dismissPopups(); &#125; &#125;); return subDecor; &#125; 再来看看那个重点标记的方法： 1234567@Override public final View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor; &#125; 哦？原来window的getDecorView()方法其实就是前面提到过的installDecor()方法诶！之前说过，installDecor()方法是什么作用来着？ 首先要初始化一个叫做DecorView的FrameLayout，他是和当前Window息息相关的。我们知道一个Activity，他的显示界面这个模块是交给了Window管理，而在Window中则是交给了DeocrView。这个DecorView会根据不同的需求（主题）来给自己填上一个不同的布局。然后在加载进来的这个布局中，有一个ViewGroup是专门用来显示我们编写的界面的，这个ViewGroup会通过findViewById()的形式在DecorView中找到，然后交给mContentParent，这样我们要将自己写的布局加载进来的时候，就是直接加载到mContentParent中就可以了。 马上接触到真相了，再随便找个刚才所引用到的布局文件看看，比如R.layout.abc_screen_simple： 123456789101112131415161718&lt;android.support.v7.widget.FitWindowsLinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/action_bar_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.v7.widget.ViewStubCompat android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/abc_action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;include layout=&quot;@layout/abc_screen_content_include&quot; /&gt;&lt;/android.support.v7.widget.FitWindowsLinearLayout&gt; 还有abc_screen_content_include.xml: 12345678910&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;android.support.v7.widget.ContentFrameLayout android:id=&quot;@id/action_bar_activity_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/merge&gt; 看看那个id:action_bar_activity_content，而且他还是很个ContentFrameLayout 发现没有？这里的SubDecorView和以前的DecorView逻辑是很像的！都是以自己作为一个大的ViewGroup，里面放另一个小ViewGroup，在这个小ViewGroup中，还有一个ViewGroup作为根布局。 捋一捋刚才的流程： 首先创建了两个DecorView，一个就是以前Activity直接用的那个DecorView，另一个叫做SubDecorView 将旧DecorView的content内容交给SubDecorView的content 将SubDecorView作为一个整体，交给DecorView 总之，就是一个替换的过程。 再回到前面看看： 123456789101112@Override public void setContentView(int resId) &#123; //这里做了刚才所说的一切，现在是两个DecorView嵌套起来了 ensureSubDecor(); //id为content的ViewGroup现在的内容其实就是以前的DecorView用的那个 ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); //清空 contentParent.removeAllViews(); //将我们自己的布局文件加载到这个contentParent中 LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged(); &#125; 至此，Activity的AppCompatActivity的setContent()的流程都分析完了，总结一下： 一个Activity，有很多功能，其中的“展示东西给别人看”这个功能，是交给自己的一个Window对象来管理的。 Window包含一个ViewGroup，作为根ViewGroup 根ViewGroup，根据不同的需求（即主题定义等）会加载不同的布局文件 以最基本的一种布局来讲，他包含一个title和一个content 我们setContent()时传入的布局文件id所指向的那个布局文件，会被加载到这个content中 Activity和AppCompatActivity在这里的区别在于，Activity单纯的用一个DecorView，AppCompatActivity则是在原来的基础上，加了一个SubDeocrView，将旧的DecorView的内容放到SubDecorView的content中，然后将SubDecorView作为整体放入旧的DecorView的content中，也就是说，一个DecorView包裹着一个SubDecorView]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》读书笔记]]></title>
    <url>%2F2017%2F10%2F25%2Fjvm_note%2F</url>
    <content type="text"><![CDATA[前言首先，java程序可以“一次编写，到处运行”就是因为有Java虚拟机这个东西作为容器。Java虚拟机作为一个中间层，向上接受由我们编写的代码生成的字节码，向下给机器提供可以被直接执行的目标代码，这就有了Java的“平台无关性”的基础。通过这个定义我们知道，一切可以编译出字节码的语言都可以获得这种“平台无关性”，也就是说像一些类Java语言比如Groovy Scala等，因为用他们也可以生成字节码，所以也可以用Java虚拟机来执行，也就具有了平台无关性。所以Java虚拟机并不只是为Java这一种语言服务的，他在一开始被创造出来的时候就被明确要具有这种拓展性。Android虚拟机其实也就是Java虚拟机的一种衍生，通过学习Java虚拟机对Android开发也是有帮助的。Java虚拟机对Java的支持可以从以下几个方面来讲：内存管理机制，类加载机制和优化。 内存管理先说内存管理。内存管理，就是Java虚拟机在运行时管理如何为程序划分内存区域，如何分配内存，内存用完如何回收。 内存区域先讲一下内存区域的划分。Java虚拟机把内存分为很多数据区域，不同的区域用途和生存周期不同。我们常常直接接触到的是运行时数据区，可以细分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器。这几个区域中，方法区和堆是所有线程共享的，所有线程都可以访问，而虚拟机栈、本地方法栈、程序计数器是线程隔离的，每个线程有自己独立的区域，线程之间是不共享的。 程序计数器：相当于一个程序执行过程中的行号指示器，类似于操作系统中的ip，指向当前执行的虚拟机字节码地址。如果执行的是Java方法，计数器就记录者正在执行的虚拟机字节码指令的地址。如果是native 方法，计数器为空 虚拟机栈：虚拟机栈就是java方法的内存模型，每一个线程在执行时会有自己的一个虚拟机栈，在运行过程中把所调用方法封装为一个栈帧，然后将栈帧存放在栈里面。栈帧包含了一个方法执行时的相关信息，包括方法用到的局部变量，操作数，动态链接等。 本地方法栈：类似于虚拟机栈，只不过他存放的是Native方法。 堆：堆是相对来说占内存最大的一块，用来存放所有线程创建的类的对象实例。方法调用中如果创建了对象，会把这个对象实例存放在堆，然后将对于这个对象的引用存放在栈中，这样就可以方法对象了。对于内存的回收，也就是对堆内存的回收了。 方法区：存放虚拟机加载的类的信息和一些常量、静态变量等，这些内容一般是不可变的。 OOM和StackOverFlowOOM和StackOverFlow就是在运行时数据区出现的。前面说了，虚拟机栈会把每次调用的方法作封装为一个栈帧存起来。这些栈帧肯定是要占内存的，而栈的内存也是有限的。如果栈帧很多一直没有释放，这时候又来了一个栈帧，这个栈帧已经没有空间可以容纳了，有两种情况。如果这种虚拟机栈不支持动态扩展，那么将会抛出StackOverFlow异常。如果支持动态扩展，那么这个栈会请求再扩展部分空间。当然内存不是无穷的，如果频繁的扩展内存，以至于无法再继续扩展了，这时候会抛出OutOfMemory异常。 除此之外，堆得空间也是有限的。由于创建的对象都是要在堆中分配内存，那么如果堆中空间不足，没有足够的内存空间用来给新的对象分配内存，这时候也会抛出OutOfMemory异常。 内存分配与回收创建一个对象，就在堆中给这个内存分配一块内存。当对象不再被使用，所占的内存就被回收，用来给其他对象。要回收内存，就要知道哪些对象会被回收，什么时候会被回收，回收的具体算法是怎么一个操作。 对象的创建——分代一个对象的创建过程很简单，比如我new一个对象，虚拟机发现这条指令后，会先看看new 后面跟着的那个参数能否在常量池中定位到一个类的符号引用，并且检查那个类是否已经被加载过。如果没有，则进行一次类的加载工作（具体细节后面会讲）。加载完成后，虚拟机会为新的对象在堆中分配一块内存，具体分配多少，在类加载完之后其实就已经定了。分配完内存，之后会将这个对象的实例字段初始化为零值。最后，会对对象进行一些设置，比如设置哈希码，分代年龄信息，这个对象属于哪个类之类的。 这一系列工作做完，这个对象才算是被创建成功了，之后才会去调用相关代码，按照我们的意愿真正做一次初始化。 创建好一个对象，还需要一个引用来持有他，这样我们才能使用。引用是放在虚拟机栈 栈帧的本地变量表中的。引用有两种形式，一种是直接持有对象地址，一种是持有一个句柄，句柄保存在堆中，包含着对象的地址，是间接访问。直接访问速度快，间接访问在对象频繁移动时比较有优势。 哪些对象会被回收？——可达性分析算法选择回收哪些对象，虚拟机有很多算法，常见的有引用计数法和可达性分析算法。引用计数法的思路就是为每一个对象设一个值，用来计算被引用的次数。只要有一个对于对象的引用存在，就让这个数字加一。这样如果一个对象没有任何引用，那么引用计数为零，这个对象就会被标记为“可回收”。但是这样有一个很严重的bug，那就是如果我有两个对象，已经不再使用，但是他们互相引用，那么他们的引用计数就永远不会为零，那么就不会被回收。 现在大部分虚拟机都采用了“可达性分析算法”，这一算法显然要比引用计数法不知道高到哪里去了。他的思想是，将一些特定的对象作为GC Roots，然后从这个节点向下寻找对其他对象的引用。如果一个对象到GC Roots没有引用链，那么就可以被回收了。在Java虚拟机中，被规定作为GC Roots的对象有： 虚拟机栈中引用的对象 方法区中 静态属性引用的对象 方法区中 常量引用的对象 JNI引用的对象 所以我们日常开发过程中遇到的内存泄漏，很大一部分原因就是本该被回收的对象无意之中被GC Roots引用到了，比如写的static这样的静态字段引用的对象，这样他就不会被回收了 回收的算法？——多种混合知道哪些对象要被回收，接下来就是具体如何回收的问题了。垃圾回收算法有很多，常见的有标记-清楚法，标记-整理法，复制算法，分代收集等。现在的虚拟机基本上都是采用以分代收集为基础，搭配其他算法一起合作完成的。这些算法就不一一介绍了，有兴趣大家可以查一查。 具体：根据对象的生存周期对内存划分为新生代 老生代，在新生代中因为每次都会有大量对象被回收，比较频繁，因此采用了复制算法。而老生代相对来说回收的对象少，没那么频繁，而且对象普遍比较大，因此采用了标记-清楚或标记-整理算法。 回收的过程？——双重标记具体的回收过程是，当在GC时发现一个对象可被回收，就会先对他做一次标记，这是第一次标记。之后会筛选一下，如果一个对象的finalized()方法是否有必要被执行。如果有，那么就会被放置到一个队列中，之后虚拟机会单独的处理这一队列中的对象，依次调用他们的finalized()方法，这里是对象复活的唯一机会。之后又会统一进行一次标记，如果这次标记标记成功，那么对象就会被认定为死亡，会立刻被回收。 GC的时机？——动态年龄判定虚拟机针对对内存回收，又把堆分为了两个区，新生代和老年代。新生代又分为一个Eden区和两个Survivor区。每次分配内存，如果对象比较大的话直接进入老年代。否则，先进入Eden区和一个Survivor区，同时会为每一个对象设一个年龄值。之后会周期性的在某个安全点检查一下，对于新生代的对象，将可回收的对象回收掉，将剩余的对象复制到另一个Survivor区，这一过程中会对年龄值加一。这一过程叫做Minor GC，是属于新生代的GC。当某些对象年龄值比较大时，会将他们移动到老年代去。当然在这之前会先查看一下老年代剩余空间是否满足移动。如果不能满足，就会对老年代进行一次GC，这一过程叫做Full GC。而这个检查对象是否可GC得时机，也就是GC的时机，一般是确定的被称作“安全点”。在这一时机进行检查，是不会影响程序正常运行的。 灵活的控制——四大引用GC的流程大致就是这样。我们知道Java中引用有四种，分别是强、软、弱、虚。这四种引用的区别就在于GC的过程中： 强引用：直接通过类名new一个对象，这样直接创建的对对象的引用叫做强引用。被强引用的对象，一般是不会被回收掉的。 软引用：被软引用持有的对象，只有在“不回收就要内存溢出”的时候，才会回收 弱引用：被弱引用持有的对象，在每次GC都会被回收 虚引用：无任何时机作用，只是一个标记，为了能使对象被回收时做一些系统通知什么的 类加载机制Java实现平台无关性的基石，就是字节码。在Java虚拟机中，有一个class文件这个概念。一般情况下，每一个类都会产生一个class文件，其内容就是字节码。虚拟机执行字节码，其实就是加载了类的class文件。Android中有两种虚拟机，Dalvik虚拟机和ART虚拟机。他们属于Java虚拟机的衍生，区别在于两个： Java虚拟机是基于栈架构的，DVM和ART是基于寄存器架构的 Java虚拟机执行的是字节码，而DVM ART都不一样。DVM会将class文件重新封装为dex文件，执行dex字节码。ART会在DVM的基础上进一步转化为本地机器码再执行。 类加载，就是说加载每一个class，而和class相对应的也就是class文件了，所以有必要大致了解一下class文件结构。 Class文件结构任何一个class文件都对应着唯一一个类或者接口的定义信息。但是类或者接口又不必一定非要在class文件中（比如动态的通过类加载器加载）。class文件是一组二进制流，其中包含额类的虽有相关信息，非常紧凑的排列在一起，很严格的规定了第几位到第几位是什么，主要包含了魔数，常量池等数据信息。 这不部分内容看起来还是很无聊的，主要关注其中一部门就好啦。比如一开头的4个字节是魔数，魔数的唯一作用是确定这个文件是否可以被虚拟机接受。 还比如，其中有一段被称为常量池入口，这个很重要了。常量池是class文件结构与其他项目关联最多的数据类型，相当于一个资源池。通过这个常量池入口，可以获得常量池信息。常量池具体而言，存放着两种类型：字面量和符号引用。 字面量：就是字面量，比如文本字符串这样的。 符号引用：包括三种常亮：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 他们的作用就是在虚拟机运行时，通过常量池入口，在常量池中找到对应的符号引用，从而找到引用的类或者方法等。 类加载机制类的生命周期氛围7个阶段： 加载 验证 准备 解析 初始化 使用 卸载 其中，验证 准备 解析 三个步骤又可以合并为 链接 所以类加载的过程就是 加载 链接 初始化了 加载的时机——按需加载虚拟机并没有规定类的加载过程什么时候开始，只是明确了类加载的生命周期是固定的。但是比较特别的是“初始化”。我们需要用到一个类的时候，就一定要“初始化”，而其他在他之前的步骤，自然也就必须要调用了。因此可以这样概括为：加载、验证、准备、解析，这个过程是不确定的，由不同虚拟机自己控制，可能不知道哪个时候就进行了。但是当我们需要用到一个类时，就必须要立刻从加载开始执行到初始化结束，之后才能使用。 那么什么时候需要这个类呢，以下几种常见情况： new一个对象，或者调用一个类的静态字段或者静态方法 反射调用一个类 子类加载前要先加载父类 虚拟机刚启动时执行主类 这些情况，都是属于对类的主动引用。 加载的过程——五步走前面说过了，类的加载过程是类的生命周期前五个步骤： 加载： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据访问入口 因为加载这个过程没有限制具体的来源，所以衍生出了很多新东西，比如Jar包的读取，从网络中加载类等。 这是对于简单类而言的。对于数组，不会通过类加载器加载，而是由虚拟机直接创建，之后才会递归的加载数组中的引用类。 验证：验证是链接过程的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机本身的安全。验证主要有四类： 文件格式验证：字节流是否符合Class文件格式规范 元数据验证：语义分析，符合语言规范 字节码验证：分析数据流，确定语义是合法的，符合逻辑的。 符号引用验证：验证符号引用合法性 准备：正式为类量分配内存并设置初值。类变量要分配在方法去中，设置初值的是类变量而不是实例变量。 解析：将常量池内的符号引用替换为直接引用。前面说过，符号引用只是以简单的通过名称等信息指出引用的方法或类，。那么在这里才会真正的将符号引用转换为直接引用，即对于方法区类的引用。直接引用类似于指针，所以这一过程可以理解为从名称到地址的转化。 初始化：前面是加载和链接的过程，这里就是类加载过程的最后一步了。所谓的初始化阶段，就是真正执行在类中写的代码了。比如实例变量的初始化和构造器等。初始化阶段也可以理解为调用类的构造器的过程。 加载的工具——类加载器前面说过，第一步“加载”过程，要通过一个类的全限定名来获取这个类的二进制字节流。这个过程，是要借助于一股虚拟机外部的工具来进行的，这一工具就是类加载器。每一个类，都有一个针对他的类加载器。两个类是否相同，不但要比较他本身，还要比较他们的类加载器。 类加载器可以分为三类： 启动类加载器：由C++编写，属于虚拟机的一部分，是属于很基础的加载器，回加载Java目录下lib中的类。 扩展类加载器：可以由开发者使用 应用类加载器：也叫做系统类加载器，加载用户类路径上自己指定的类，我们平时使用也基本是使用这个。 而具体的加载逻辑，被称为“双亲委派模型”，即首先有一个根部的加载器“启动类加载器”，其下有一个儿子叫“扩展类加载器”，其下是“应用程序类加载器”，最后是“自定义类加载器”。具体流程： 一个类收到了加载的请求，首先会把请求委托给父类加载，每一个加载器都是如此。这样最终会把请求交给根节点的“启动类加载器”。之后如果父加载器可以加载，就会直接加载。否则，会将请求再传下来。 虚拟机优化Java的编译期，是一个极不确定的过程。因为Java的编译期很多，有前端编译期，有后端编译器，还有静态提前编译器。前端编译期负责将.java转化为简单的.class，后端编译器负责将字节码转换为机器码，如JIT。静态提前编译器会将.java直接翻译为本地机器码，如AOT。因此，编译期并不能很精准的分类，因此只能大概分为“早期”和“晚期”。 早期优化早期阶段，可以概括的看做前端编译器将.java转化为.class的过程。这一阶段的优化又可以称作编译期优化。 这一阶段其实和其他语言的编译期优化类似，无非就是词法、语法分析，语义分析，然后做一些语言层面的优化。比如，语法糖、注解的处理，还有字符串拼接。Java语法糖不多，但是挺实用的，诸如类型擦除啊，自动拆箱、装箱啊。注解是在编译时进行优化，具体在运行时才会体现出作用。还有一个例子，我们都知道String StringBuilder StringBuffer区别。都说每次用”+”链接两个字符串的时候都会new一个String，这样会很耗内存。其实这个说法并不全对。如果仅仅是一个个拼接，哪怕是换行，编译器如果识别到，都会为我们优化，即将他们作为一个String对象。只有个别情况，比如在循环结构中频繁的链接字符串，才会出现刚才说的那个问题。 运行期优化运行期优化，比较熟知的比如JIT和AOT。虚拟机之所以这样分开，是为了增加虚拟机扩展性，也就是说普通的前端编译期只接受Java。而后端编译器则可以接受像Groovy等语言。同时JIT和AOT对编译的性能优化很大，因此也就被选作Android中Java虚拟机所使用的编译器了。 先说JIT，他是将字节码转换为了机器码，这是DVM采用的编译器。他的特点可以打个比方，比如让你背一首诗，而且还要当着我的面背出来，还要重复背好几次，那么你肯定需要背好久，才能一次念出来。通过JIT，我可以让你照着书，看一个字背一句。这样背起来就很轻松了。但是JIT也不一定真的就远比普通的解释器执行慢。在JVM中，JIT是针对热点代码的，对于这些代码才会进行JIT编译。因此JIT就编译本身转化过程而言也是比较慢的，快是快在执行上。还是那个例子，如果只让你大概总结一下意思，就背几句诗，那么你翻书还不如直接背的快。而对于热点诗句，你能看一眼念一句，那么这个速度是相当快的。 再说AOT。AOT是直接将.java转换为本地机器码。拿上面那个例子来说，我给你的这篇古诗，其实你以前就背过一部分，所以现在再背一小部分就可以了，所以速度快，但是代价是，需要提前准备，因此占据脑容量大。 在Android中，以前的DVM采用了JIT，而现在的ART采用了AOT。具体区别在于DVM编译时，安装过程比较快，占空间小，但是执行比较慢。而AOT则是安装过程慢，占空间大，但是执行快。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析-从AIDL了解Binder机制]]></title>
    <url>%2F2017%2F10%2F25%2Fsource-binder%2F</url>
    <content type="text"><![CDATA[从AIDL了解Binder前面简单学习了一下AIDL的用法，接下来就从AIDL入手，探究一下Binder机制。在学习的过程中，看了以下几篇文章，觉得很有价值：彻底理解Android Binder通信架构Binder学习指南Android Bander设计与实现 - 设计篇 背景知识首先要知道的是，在Linux系统中，存在很多进程，不同进程之间，数据是不会共享的，他们各自有自己的空间。因此两个进程之间要想交换数据，需要一种机制来做一条数据通路。 还有一点，在Linux系统中，存在内核空间和用户空间两个概念。Linux内核是需要高度安全机制保护起来的，而我们的应用程序则只能运行在开放的用户空间中。如果应用程序需要访问内核空间，需要通过系统调用来实现。 因此，要想实现进程间的通信，我们可以通过在内核空间做一个“枢纽”，不同的进程虽然互相没法访问各自的内存，但是他们都可以用过系统调用来访问我们创建的“枢纽”。Binder机制就是这样的一个“枢纽系统”。 既然Android系统基于Linux系统，那么为什么要自创一套Bidner机制，而不用Linux现成的呢？在知乎上有篇回答很好：为什么Android系统要采用Binder机制做IPC? Binder通信模型首先在内核中，存在一个作为枢纽的东西，叫做Binder Driver（Binder驱动）。在Binder机制中，每一个进程最终都是需要在这里完成数据的交接。 其次，还有一个作为核心服务的东西叫做ServiceManager，与Binder Driver不同的是，他处于用户空间。 这两者，构成了Binder机制的核心。 举个例子，现在又两个进程A和B，A要访问B中的一个对象obj的方法f()，这就是跨进程通信了。那么在这之前，进程B会将自己注册在ServiceManager中，也就是说在这里存在一个表，进程B首先会把自己的信息作为一条数据插入在表中。之后，进程A要访问进程B，只需要访问这个ServiceManager，在这里查找B的先关信息，然后他就可以得到这个对象obj，之后就可以直接调用方法f()。 在这个流程里面，实际上并没有真的获取到对象obj，只是获取了一个obj的代理对象。实际对象还是在进程B中。调用f()时，传入的参数只会交给这个代理对象，然后代理对象再负责把数据交给真实对象。而在这整个流程之中，A和B还有ServiceManager都是进程，他们之间的数据交换都是要直接交给Binder驱动的。说起来有点乱，画个图就看出来了： 图中，虚线表示两者之间不是直接交互，因为这三者之间的交互实际上都是通过实线做的。 从AIDL到BinderAIDL说白了其实就是帮我实现了一个可以用作Binder通信的类，抛开AIDL,我们自己也可以写一个差不多的，也可以用。通过AIDl自动生成的类，定义了一个内部类，并让内部类继承了Binder类。所以，我们只需继承Binder，也可以做简单的IPC了。 从Client开始从MyAidlClient开始，探寻一下Binder通信的流程。 首先，如图所示 通过已经获得的IBinder对象，这里调用asInterface()方法，返回了一个IMyAidlInterface类的对象，调用他的add()方法。那就从这里开始： IMyAidlInterface.java: 12345678910111213141516171819/** * Cast an IBinder object into an com.levent_j.myaidlserver.IMyAidlInterface interface, * generating a proxy if needed. */ public static com.levent_j.myaidlserver.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; //非空判断 if ((obj == null)) &#123; return null; &#125; //查找本地是否存在 如果存在，则直接可以使用，就不需要跨进程通信了 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.levent_j.myaidlserver.IMyAidlInterface))) &#123; return ((com.levent_j.myaidlserver.IMyAidlInterface) iin); &#125; //没有找到，那么就只能跨进程通信了 //这里通过IBinder对象创建了一个Proxy对象并返回 //从名字就可以看得出，返回了一个代理对象 return new com.levent_j.myaidlserver.IMyAidlInterface.Stub.Proxy(obj); &#125; 再来 12345678910111213141516//首先要知道，这个类实现了那个接口private static class Proxy implements com.levent_j.myaidlserver.IMyAidlInterface &#123; //持有的一个IBinder对象的引用 private android.os.IBinder mRemote; //创建对象的时候，只是让代理对象保持了对IBinder对象的引用 Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; //返回保存的那个引用 @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; //………… &#125; 调用asInterface()方法到这里就结束了，可以看到实际上返回来一个代理对象Proxy，那么之后调用add()方法也就是调用了代理对象的add()方法，也就是Proxy类的add()方法： 12345678910111213141516171819202122232425262728@Override public int add(int arg1, int agr2) throws android.os.RemoteException &#123; //创建两个Parcel对象 //obtain()方法意味着这儿有个Parcel对象的缓存池，避免浪费 //Parcel对象就是支持跨进程对象的数据结构 //这个_data用来存放调用的方法的请求参数 android.os.Parcel _data = android.os.Parcel.obtain(); //_reply用来存放返回结果 android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; //先向_data中写入数据 _data.writeInterfaceToken(DESCRIPTOR); //两个arge刚好就是我们传入的参数 _data.writeInt(arg1); _data.writeInt(agr2); //重点来了，这里调用了IBinder对象的transact()方法 mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; //最后释放掉 _reply.recycle(); _data.recycle(); &#125; return _result; &#125; 这个IBinder类是个接口，而在这获取的对象实际上是Binder.java中的内部类BinderProxy类的对象（什么？Proxy？对没错，这里又是一个代理）。那么获取到这个BinderProxy对象之后，如上所示调用了他的transcat()方法，将参数传入，之后数据传到Server那里，经过实际对象的add()之后会取得返回值。所以这里就是Binder的起点了： 1234567891011121314151617181920212223242526272829303132//参数code为前面的Stub.TRANSACTION_add，作用是做一个标识，后面会用到//两个Parcel对象，作为数据//最后flags为0public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; //先检查一下两个Parcel Binder.checkParcel(this, code, data, "Unreasonably large binder buffer"); if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) == 0)) &#123; // For now, avoid spamming the log by disabling after we've logged // about this interface at least once mWarnOnBlocking = false; Log.w(Binder.TAG, "Outgoing transactions from this process must be FLAG_ONEWAY", new Throwable()); &#125; final boolean tracingEnabled = Binder.isTracingEnabled(); if (tracingEnabled) &#123; final Throwable tr = new Throwable(); Binder.getTransactionTracker().addTrace(tr); StackTraceElement stackTraceElement = tr.getStackTrace()[1]; Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, stackTraceElement.getClassName() + "." + stackTraceElement.getMethodName()); &#125; try &#123; //最后是调用了transactNative()方法，也就是到了Native层 return transactNative(code, data, reply, flags); &#125; finally &#123; if (tracingEnabled) &#123; Trace.traceEnd(Trace.TRACE_TAG_ALWAYS); &#125; &#125; &#125; 看这个方法的定义： 123public native boolean transactNative(int code, Parcel data, Parcel reply, int flags) throws RemoteException; 从这里开始，就进入了native层： 在android_util_Binder.cpp中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; if (dataObj == NULL) &#123; jniThrowNullPointerException(env, NULL); return JNI_FALSE; &#125; //将Java的Parcel转换为C++的Parcel Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) &#123; return JNI_FALSE; &#125; Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL &amp;&amp; replyObj != NULL) &#123; return JNI_FALSE; &#125; //此时target指向了BpBinder //这是开机时Zygote调用AndroidRuntime::startReg方法来完成jni方法的注册 //其中register_android_os_Binder()过程就有一个初始并注册BinderProxy的操作 IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); if (target == NULL) &#123; jniThrowException(env, "java/lang/IllegalStateException", "Binder has been finalized!"); return JNI_FALSE; &#125; ALOGV("Java code calling transact on %p in Java object %p with code %" PRId32 "\n", target, obj, code); bool time_binder_calls; int64_t start_millis; if (kEnableBinderSample) &#123; // Only log the binder call duration for things on the Java-level main thread. // But if we don't time_binder_calls = should_time_binder_calls(); if (time_binder_calls) &#123; start_millis = uptimeMillis(); &#125; &#125; //这里就是BpBinder的transact() //printf("Transact from Java code to %p sending: ", target); data-&gt;print(); status_t err = target-&gt;transact(code, *data, reply, flags); //if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print(); if (kEnableBinderSample) &#123; if (time_binder_calls) &#123; conditionally_log_binder_call(start_millis, target, code); &#125; &#125; if (err == NO_ERROR) &#123; return JNI_TRUE; &#125; else if (err == UNKNOWN_TRANSACTION) &#123; return JNI_FALSE; &#125; signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize()); return JNI_FALSE;&#125; 然后是BpBinder.cpp中的transact()方法： 123456789101112131415status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // Once a binder has died, it will never come back to life. if (mAlive) &#123; //IPCThreadState采用单例模式 //返回了一个status status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 到了IPCThreadState.cpp的transact()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566tatus_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot; &lt;&lt; handle &lt;&lt; &quot; / code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl; &#125; if (err == NO_ERROR) &#123; LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(), (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;); //传输数据 //看函数名应该是写入数据了 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; //根据是否是ONE WAY方式而分别给waitForResponse()传了不同的参数 if ((flags &amp; TF_ONE_WAY) == 0) &#123; #if 0 if (code == 4) &#123; // relayout ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;); &#125; else &#123; ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code); &#125; #endif if (reply) &#123; //等待应答 err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; #if 0 if (code == 4) &#123; // relayout ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;); &#125; else &#123; ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code); &#125; #endif IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot; &lt;&lt; handle &lt;&lt; &quot;: &quot;; if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl; else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl; &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125; 这里的write方法显然是写入数据 12345678910111213141516171819202122232425262728293031323334353637//写入数据 //此时cmd:BC_TRANSACTIONstatus_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; //创建一个binder_transaction_data数据结构 binder_transaction_data tr; tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */ tr.target.handle = handle;//handle指向AMS tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123;//数据没有错误，则封装数据 tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; //给mOut写数据 mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 可以看出，mOut用来将数据写入那么在将数据写入之后，来到了这个waitForResponse()方法，等待应答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; //一个死循环，一直等待返回数据 while (1) &#123; //调用taklWithDriver()方法，返回一个错误码 //如果有error 则break if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; //没有可用数据，继续循环 if (mIn.dataAvail() == 0) continue; //从mIn读数据 cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Processing waitForResponse Command: &quot; &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; //通过cmd switch (cmd) &#123; //本次通讯结束 case BR_TRANSACTION_COMPLETE: if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: err = DEAD_OBJECT; goto finish; case BR_FAILED_REPLY: err = FAILED_TRANSACTION; goto finish; case BR_ACQUIRE_RESULT: &#123; ALOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;); const int32_t result = mIn.readInt32(); if (!acquireResult) continue; *acquireResult = result ? NO_ERROR : INVALID_OPERATION; &#125; goto finish; case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; &#125; return err;&#125; 还有talkWithDriver()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//交给Driver处理 此时mOut已经有了数据，mIn还没有，这里来处理数据status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don&apos;t want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; IF_LOG_COMMANDS() &#123; TextOutput::Bundle _b(alog); if (outAvail != 0) &#123; alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent; const void* cmds = (const void*)bwr.write_buffer; const void* end = ((const uint8_t*)cmds)+bwr.write_size; alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl; while (cmds &lt; end) cmds = printCommand(alog, cmds); alog &lt;&lt; dedent; &#125; alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl; &#125; //输入和输出数据都为空则直接返回 // Return immediately if there is nothing to do. if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125;#if defined(__ANDROID__) //ioctl()执行到Binder Driver中 这里才是真正与Driver通信了 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno;#else err = INVALID_OPERATION;#endif if (mProcess-&gt;mDriverFD &lt;= 0) &#123; err = -EBADF; &#125; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125; &#125; while (err == -EINTR); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)(intptr_t)err &lt;&lt; &quot;, write consumed: &quot; &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize() &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl; &#125; if (err &gt;= NO_ERROR) &#123; if (bwr.write_consumed &gt; 0) &#123; if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; IF_LOG_COMMANDS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent; const void* cmds = mIn.data(); const void* end = mIn.data() + mIn.dataSize(); alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl; while (cmds &lt; end) cmds = printReturnCommand(alog, cmds); alog &lt;&lt; dedent; &#125; return NO_ERROR; &#125; return err;&#125; 所以talkWithDriver()方法是直接去和Binder驱动通信了，其核心是ioctl()方法。 在通信结束之后，回到最初的起点，等待得到返回值（如果有的话），最后从mIn拿到返回的数据。 Server端做了什么现在已经知道了，数据通过Binder代理，现在已经到了Server端，主要处理过程在内部类Stub中的onTransact()方法内： 1234567891011121314151617181920212223@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; //正是这个方法标识，要调用add()方法 case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); //这里调用add() int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; 曾记否，在Server端重写了add()方法，对没错，这里就是调用了那个add()方法 总结总体上来说，Binder的整个流程就是： Client 创建binder_transaction_data 填code 参数填入data.buffer 填入target.handle(Client端的引用) BC_TRANSACTION发送给Binder驱动 查找目标，填写target.ptr(Server端的实体） 到接受线程 调用onTransact()方法 Server 我们说，Bidner相较于其他IPC机制的一个优势就在于只存在一次拷贝。那么这是怎么一回事呢？通过mmap()映射了一片缓存池，数据拷贝时，binder_transaction_data是可以分为很多部分，但是其中只有一个叫做buffer的部分是大小不可预料的，其他的部分其实大小是限定的。因此除了buffer之外的其他部分由接收方自己提供，而buffer的存储区由缓存池提供，这样就完成了数据的“一次拷贝”，给人的感觉就是完整的数据直接从Client端拷贝到了Server端，实际上还是借助了内核。]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Activity启动与生命周期]]></title>
    <url>%2F2017%2F10%2F25%2Fsource-startactivity%2F</url>
    <content type="text"><![CDATA[Activity启动流程就拿最简单的启动方式，即startActivity(Intent)来看，首先是在Activity.java中： 1234@Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125; 调用重载的startActivity()方法，多传入一个空的bundle参数: 123456789public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; 因为bunlde为null，所以走下面这个路径： 1234567891011121314151617181920212223242526272829public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 这里有个疑问，mParent是何用？在网上查阅资料后得知，这个东西是ActivityGroup的遗物，一般Activity是没有的，所以这里会走if这条路。那么可以看到启动Activity时主要在这里： 123456789101112Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; 先调用mInstrumentation的execStartActivity()方法，启动Activity，启动完毕之后然后拿到返回的启动结果作为一个ActivityRersult，有了这个result就可以做ActivityResult()。那么首先来看一下execStartActivity()方法是怎么执行的：在Instrumentation.java类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; //先获取一个IApplicationThread引用 IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; //这里大概时候做一重过滤，如果Activity实例已经存在，则不启动？ if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; //真正的启动逻辑 intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); //先通过ActivityManager获取一个ActivityManagerService引用，然后具体调用的是AMS的startActivity()方法 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //调用之后，检测一下启动的Activity是都合理 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null; &#125; AMS即ActivityManagerService，这里是用过Binder机制远程调用了他。现在看ActivityManagerService.java的startActivity()方法: 123456789@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 调用了startActivityAsUser()方法： 1234567891011121314@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, "startActivityAsUser"); &#125; 在获取了一个userId之后，调用了mActivityStarter的mActivityStarter.startActivityMayWait()方法。这个mActivityStarter是一个ActivityStarter类的对象，这个类主要用来做Activity启动之前的准备工作，比如intent和flags的逻辑，管理stack和taskrecord等。接下来进入了ActivityStarter.java中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask, String reason) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; //处理intent SResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); if (rInfo == null) &#123; UserInfo userInfo = mSupervisor.getUserInfo(userId); if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) &#123; // Special case for managed profiles, if attempting to launch non-cryto aware // app in a locked managed profile from an unlocked parent allow it to resolve // as user will be sent via confirm credentials to unlock the profile. UserManager userManager = UserManager.get(mService.mContext); boolean profileLockedAndParentUnlockingOrUnlocked = false; long token = Binder.clearCallingIdentity(); try &#123; UserInfo parent = userManager.getProfileParent(userId); profileLockedAndParentUnlockingOrUnlocked = (parent != null) &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id) &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; if (profileLockedAndParentUnlockingOrUnlocked) &#123; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE); &#125; &#125; &#125; // Collect information about the target of the Intent. //处理Activity，找到相对应的Activity组件，并且保存Intent ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); //…………………… //这里处理Activity任务栈相关内容 final ActivityRecord[] outRecord = new ActivityRecord[1]; int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason); mSupervisor.mActivityMetricsLogger.notifyActivityLaunched(res, outRecord[0]);//……………… &#125; 在这面首先获取了传入的Intent等信息，之后交给startActivityLocked()方法来创建ActivityRecord，这其中就包含着Activity的重要信息。在这一方法中，层层调用之后来到了这里： 123456789101112131415private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); //这里调用了startActivityUnchecked()方法，是根据启动的flag信息，设置taskRecord. result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; // If we are not able to proceed, disassociate the activity from the task. //………… &#125;&#125; 在调用startActivityUnchecked()时，最终走到了ActivityStackSupervisor.java中： 12345678910111213141516171819boolean resumeFocusedStackTopActivityLocked() &#123; return resumeFocusedStackTopActivityLocked(null, null, null);&#125;boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); &#125; return false;&#125; ActivityStackSupervisor类与ActivityStack类配合使用. ActivityStackSupervisor负责管理Task和Stack, 而ActivityStack负责管理在Stack和Task中的Activity。 这里会调用activityStack的resumeTopActivityUncheckedLocked()方法，然后开始一个调用链：ActivityStack的resumeTopActivityInnerLocked() -&gt;ActivityStackSupervisor的startSpecificActivityLocked() -&gt; ActivityStackSupervisor的realStartActivityLocked() 到这里，正如方法名所描述的那样，真正开始启动Activity了： 123456789app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global and // override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 最后由ActivityThread中的ApplicationThread调用scheduleLaunchActivity完成Activity的真正启动。这里的thread是IApplicationThread接口，该接口继承了IInterface接口，实现方法asBinder()方法作为binder通信。 所以最终的启动就到了ActivityThrad.java中，怎么，熟不熟悉？ 12345678910111213141516171819202122232425262728293031323334public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 很显然，启动Activity是要先创建一个ActivityClientRecord对象，然后通过Handler消息机制来告诉我们的主线程来启动，直接来看H.LAUNCH_ACTIVITY这条消息的处理： 12345678case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, "LAUNCH_ACTIVITY"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); 调用了hanlleLaunchActivity()方法用来启动Actiivity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, "Handling launch of " + r); //先初始化 // Initialize before creating the activity WindowManagerGlobal.initialize(); //创建一个Activity实例并返回，在这里面调用了新Activity的onCreate() Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; //执行创建完成的新Activity的onResume()方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; // The activity manager actually wants this one to start out paused, because it // needs to be visible but isn't in the foreground. We accomplish this by going // through the normal startup (because activities expect to go through onResume() // the first time they run, before their window is displayed), and then pausing it. // However, in this case we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just retain the current // state it has. //旧的Activity的onPause()方法 performPauseActivityIfNeeded(r, reason); // We need to keep around the original state, in case we need to be created again. // But we only do this for pre-Honeycomb apps, which always save their state when // pausing, so we can not have them save their state when restarting from a paused // state. For HC and later, we want to (and can) let the state be saved as the // normal part of stopping the activity. if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. try &#123; ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; 其中最主要的就是performLaunchActivity()方法了，在这里创建了最终的Activity实例，来看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //创建的新Activity所需的一些参数 ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建和每一个Activity相对应的Context ContextImpl appContext = createBaseContextForActivity(r); //这里终于开始创建Activity了！ Activity activity = null; try &#123; //通过要创建的Activity的类加载器来创建一个对象 java.lang.ClassLoader cl = appContext.getClassLoader(); //就是这儿，创建了一个Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, "Performing launch of " + r); if (localLOGV) Slog.v( TAG, r + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + r.packageInfo.getPackageName() + ", comp=" + r.intent.getComponent().toShortString() + ", dir=" + r.packageInfo.getAppDir()); if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); //创建一个Window Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); //每一个Activity在这里和Window作绑定 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //这儿就是Activity的第一个生命周期 onCreate()的执行！ if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //层层调用，最后是Activity的生命周期onStart()! activity.performStart(); r.stopped = false; &#125; //做一些状态恢复之类的 if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onPostCreate()"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to start activity " + component + ": " + e.toString(), e); &#125; &#125; return activity;&#125; 到此为止，startActivity()的所有流程就走了一遍]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存泄漏那些事儿]]></title>
    <url>%2F2017%2F07%2F27%2Fandroid_memory_leak%2F</url>
    <content type="text"><![CDATA[内存泄漏java gc首先要有一个大前提，也就是java gc。在大部分虚拟机（包括Android的ART）中，Java都采用了“可达性分析”算法来进行内存回收，原理是：会有几个引用作为root节点，对于任意对象来说，如果从root层层遍历，如果找不到对于他的引用链，那么这个对象就被标记为无用，就会在gc时被销毁。 何为泄漏内存泄漏，即部分对象虽然已经不再使用，但是因为有root持有引用，所以并没有被销毁，所占用的内存一直没有被释放。一次两次发生影响不大。如果频繁发生，那么可用内存会渐渐不足，最终在某一次请求内存时发现内存不足而发生oom。这里要明确一个概念，只有强引用会发生内存泄漏，而weak等引用因为其特殊机制，所以影响不大。 什么会泄露泄露影响比较大的就是一些大对象，常见的比如某些资源，bitmap，以及activity。 如何发生泄露首先让我们从另一个角度来看，如何主动发生内存泄漏呢？当然是想办法给他一个一直存在的强引用了。 staticstatic这个关键字使一个变量变为只和这个类相关的类变量，和实例无关。他的生命周期是很长的，贯穿于app的启动到关闭。因此只要用一个static引用一个大对象，就可以泄漏了！举个例子： 1static Activity activity; 这是最简单粗暴的持有一个activity的引用，这样这个activity退出之后对象并没有被销毁。 1static View view; 一个View初始化时会用到context，我们在自定义View，重写构造方法时就知道这个了。因此如果一个View也像这样被持有，那个context也不会被释放。 innerClass内部类有个特性，是他会持有一个外部类的引用。如果内部类的实例一直存活，那么外部类activity的实例也就一直在。比如持有一个static的内部类引用： 12345static LeakInnerClass context;class LeakInnerClass &#123; Context context;&#125; 或者以前我们用asynctask时喜欢搞一个匿名内部类执行异步任务，那当我们activity退出后这个异步任务还在执行的话，就会泄露了。 123456789101112void leakAsyncTask()&#123; new AsyncTask&lt;Void,Void,Void&gt;()&#123; @Override protected Void doInBackground(Void... params) &#123; while(true)&#123; //哇啦啦啦啦啦啦我就是耗时操作 &#125; return null; &#125; &#125;;&#125; 还有自己开个匿名线程： 12345678910void leakThread()&#123; new Thread()&#123; @Override public void run() &#123; while (true)&#123; //哇啦啦啦啦啦啦我是耗时操作 &#125; &#125; &#125;.start();&#125; 还有在使用handler时，如果用了匿名handler，那么这个handler会带着activity的引用藏到消息队列中。消息没有被处理，就会造成内存泄漏。类似的，还有timertask等。 register我们平时会用到很多第三方库，比如ButterKnife EventBus RxJava等等，有的时候要获取系统服务，getSystemService。在使用的时候，都有一个先registerd或者bind的操作，而且在创建的时候会把activity的引用传过去。如果在activity结束时没有unregister或者unbind，就会造成内存泄漏。 如何检测泄漏最简单的方法自然就是使用leakcanary了。只要给自己的项目加上这个工具，在发生泄漏的时候很快就会有提示。具体使用方法看这里。 除此之外，android studio的刀耕火种的方式也不错，在这里我拿一个例子来示范一下我是怎么用的。 一次leak检测过程准备工作首先，我写了两个activity，一个MainActivity，一个MemoryLeakActivity，逻辑是：MainActivity中有个按钮，点击会调到MemoryLeakActivity，在这个activity中会故意发生内存泄漏，代码如下： 在开始之前，再熟悉一下这个 （原谅我拙劣的画笔） 这个Monitors可以观察当前选中app的运行状态，现在只需要关注我标了123的地方。 首先这个Memory就是当前app的内存使用状况： 1.产生一个当前java堆的.hprof文件，这个文件反映了当前时刻java堆中内存详情，记住这个玩意有大用！ 2.手动进行一次gc 3.这一块很重要，首先他有两个部分，蓝色和灰色。蓝色部分是当前内存使用大小，灰色部分是这个app被限制的最大内存大小。当蓝色部分越来越大，最后和灰色部分一样时，说明我们内存使用很多了即将内存不足，此时会进行一次gc同时将回灰色部分即限制的大小提高。 肉眼观察好了，介绍完这个工具，我们开始动手实践。首先打开app，点击按钮跳到会发生泄漏的activity上，再按返回键，然后再次按下按钮……这样反复操作： 与此同时，观察monitors的memory窗口，会发现蓝色部分在每一次开启新activity时会增长一部分，这很正常。但是在返回时，明明activity被“退出”了，但是蓝色部分还是没有变化。反复几次之后，蓝色部分一直在增长。也就是说当前内存越用越多，可以推断已经发生内存泄漏啦~ 自动分析接下来由android studio来分析一下。在反复几次上面的操作之后，返回MainActivity，然后点击dump java heap按钮，然后等一会儿，android studio在为我们dump此时的horof文件。在成功后，会自动打开： 如图在这个界面中，我们看最右面有一个栏叫 Analyzer Tasks，打开它，会发现有两个选项。我们是来看activity的内存泄漏的，那就把那个查重复字符串的√去掉。然后点右边那个绿色小三角，会发现下面Analysis Results栏里面展示出了当前泄露的Activity引用： 点击第一个item，最下方Reference Tree栏中便展示出了具体的引用： 一般来说，第一个就是我们发生泄漏的地方。在图中，this$0的意思是隐式的引用。也就是说，我们的activity是因为一个内部类而发生了内存泄漏。 再点击刚才results中第二个item，看一下下方的reference tree: 可以看到显式的有一个leakCntextRef引用，这说明我们有一个名为leakCntextRef的引用持有了activity。回过头看看我们的代码，果然，验证的没错。 拓展android studio的分析还算比较简单而且内容较少，我们可以把这个hprof导出，然后用mat来分析，具体看这里。 怎么解决泄漏既然发生了泄漏，那就要解决它，避免问题出现。那么怎么解决呢？很简单，泄漏是因为持有了activity引用导致无法被销毁，那么只有两个选择：及时取消引用，或者让这个引用多待一会，但是该gc的时候就销毁。 根据这个思路： 我们在代码中能不用static变量持有contxt就不用，非要用就用weak引用。 对于内部类，尽量用静态内部类，这样就不会持有外部类引用。如果需要外部类引用做一些事，就手动赋给一个weak引用。 对于匿名内部类，不要图简单方便，实在不行就乖乖的写成外部类。 异步操作，尽量用可以方便管理的，比如rxJava，而不是用老古董AsyncTask了。非要用也最好加一个终止条件，在退出Activity时就该结束了。 在用rx时，可以在subscribe()的时候获取到Subscripeion，在不用的时候手动unSubscribe()，或者直接bind()到Activity的生命周期上，比如使用RxActivity管理。 在使用handler时，记得在activity的onDestroy()中加上remove() 在获取到某些资源时，使用完记得释放 在用到一些大对象比如Bitmap啊什么的，要记得回收 最后，在使用各种第三方库或者系统服务的时候还要记得有注册或绑定就要有解除注册、解绑定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础知识复习]]></title>
    <url>%2F2017%2F07%2F25%2Freview-cs%2F</url>
    <content type="text"><![CDATA[操作系统操作系统算是基础了，重点就这么几个 进程 什是进程？一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 进程是资源申请和系统调度的基本单位 进程描述了程序的动态执行过程。 对应处理机、存储器和外设等资源的分配和回收 反映系统中程序执行的并发性、随机性和资源共享 多进程提高了对硬件资源的利用率，但有带来了额外的空间和时间开销，增加了OS的复杂性 进程与程序 进程是动态的，程序是动态的 进程是暂时的，程序是永久的 进程与程序的组成不同 进程更能真实的描述并发，程序不能 进程可创建其他进程，程序不能 一个程序对应于若干个不同的进程，进程是程序的一次执行 进程生命周期新建-就绪-执行-阻塞-刮起阻塞-挂起就绪-退出 进程间通信通信分为低级通信和高级通信 低级通信：以信号量作为通信工具，交换的信息量少 高级通信：操作系统提供的一组通信命令，高效的传送大量数据 高级通信的方式：共享内存、消息队列、管道、套接字、文件、信号、内存映射文件 进程与线程区别概念上： 进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位 线程：一个进程内的基本调度单位，一个进程可以包含一个或多个线程 从执行结果看： 进程：用够独立的内存单元，而多个线程共享内存 线程：每一个独立的线程都有一个程序运行的入口、顺序执行序列、程序的出口。但是线程不能独立执行，必须依存在应用程序中 从逻辑角度看： 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看做多个独立的应用，来实现进程间的调度和挂你及资源分配 死锁什么是死锁？多个进程在运行过程中因争夺资源而造成一种僵局，当进程处于这种僵持状态时若无外力作用，他们都将无法向前推进 产生的原因 资源不足导致的资源竞争：多个进程所共享的资源不足，引起他们对资源的竞争而产生死锁 并发顺序不当：当进程运行过程中，请求和释放资源的顺序不当，而导致进程死锁 充要条件互斥-占有且等待-非剥夺-循环等待 处理死锁的基本方法预防-避免-检测接触-忽略 虚拟存储具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充 计算机网络计算机网络也有部分考点 OSI模型及每一层作用OSI模型，按自顶向下可分为五层或七层，一下按五层来讲，分别是： 应用层： 传输层：端到端可靠报文传递和错误恢复 网络层：数据包从源到宿的传递和网际互联 链路层：将比特组装成帧 点到点传递 物理层：通过物理媒介传输比特 IP地址作用及分类IP地址是ip协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异 ARPARP是地址解析协议。 原理： 每个主机都会在自己的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应的IP地址的目的主机的MAC地址，如果有则直接发送数据，如果没有就要向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址、源主机MAC地址，目的主机IP地址。 当本网络的所有主机收到该ARP数据包时，首先会检查数据包中IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP地址和MAC地址写入到ARP列表中，如果已存在，则覆盖，然后将自己的MAC地址写入到ARP响应包中，告诉源主机自己是他想要找的MAC地址。 源主机收到ARP响应包后，将目的主机的IP地址和MAC地址写入到ARP列表中，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败 TCP三次握手四次挥手三次握手： ​ 第一次：客户端向服务器发送syn，进入SYN_SEND状态 ​ 第二次：服务器接收到syn，确认客户端的SYN，同时自己也发送一个SYN包，即SYN+ACK包，进入ESTABLISHED状态 ​ 第三次：客户端接收到服务器的SYN_ACK包，向服务器发送确认包ACK，进入ESTABLISHED状态，完成三次握手。 四次挥手： ​ 第一次：主动方发送一个FIN，关闭主动方到被动方的数据传送 ​ 第二次：被动方收到FIN后，发送一个ACK给对方 ​ 第三次：被动方发送一个FIN，关闭被动方到主动方的数据传送 ​ 第四次：主动方收到FIN，发送一个ACK给被动方 TCP UDP 区别 TCP建立长连接，是安全可靠的数据传输，而UDP不会建立连接，是不可靠的 TCP传输的单位是TCP报文段，UDP传输单位是用户数据报 TCP注重安全性，UDP传数据快，安全性一般 TCP对应的协议：FTP Telnet SMTP POP3 HTTP UDP对应的协议：DNS SNMP TFTP 浏览器中输入www.baidu.com后的执行过程1.客户端通过DNS解析到域名对应的IP地址，通过这个IP地址找到客户端到服务器的路径，客户端浏览器通过发起一个HTTP会话，然后通过TCP进行封装数据包，输入到网络层 2.在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口号 3.客户端网络层通过查找路由表确定如何到达服务器 4.客户端在链路层将包发送到路由器，通过邻居协议查找到给定的IP地址的MAC地址，然后发送ARP请求查找到目的地址，如果得到回应的话就可以使用ARP的请求应答交换IP数据包现在就可以传输了]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inflate()方法的那些坑]]></title>
    <url>%2F2017%2F07%2F22%2Fandroid-inflater%2F</url>
    <content type="text"><![CDATA[三个参数的关系参见官方文档，对这三个参数的介绍是：被填充的层是否应该附在root参数内部？如果是false，root参数只适用于为xml根元素View创建正确的LayoutParams的子类。 什么意思呢？就是说，如果attachToRoot为true，那么resource指定的布局文件就会依附于root指定的ViewGroup，然后这个方法就会返回root，否则，只会将resource指定的布局文件填充并将其返回，具体可以参考源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(&quot;Creating params from root: &quot; + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(&quot;-----&gt; start inflating children&quot;); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(&quot;-----&gt; done inflating children&quot;); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; &#125; catch (Exception e) &#123; InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; &#125; finally &#123; // Don&apos;t retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; &#125; &#125; 总结一下，就是： 若attachToRoot为true且root不为null，则调用root.addView()方法 若root为null，或者attachToRoot为false，则直接将temp赋于result(temp是通过root构造的，result就是root) 何时为true，何时为false?就拿我们的Adapter来说吧，在创建item布局时，有下列几种情况： inflate(R.layout.xxx,null); inflate(R.layout.xxx,parent,false); inflate(R.layout.xxx,parent,true); 那么就讲一下这三种情况把。 首先，inflate(R.layout.xxx,null) 。这是最简单的写法，这样生成的布局就是根据R.layout.xxx返回的View。要知道，这个布局文件中的宽高属性都是相当于父布局而言的。由于没有指定parent，所以他的宽高属性就失效了，因此不管你怎么改宽高属性，都无法按你想象的那样显示。 然后，inflate(R.layout.xxx,parent,false)。相较于前者，这里加了父布局，不管后面是true还是false，由于有了parent，布局文件的宽高属性是有依靠了，这时候显示的宽高样式就是布局文件中的那样了。 最后，inflate(R.layout.xxx,parent,true)。这样……等等，报错了？？？哦，不要惊奇，分析一下原因：首先，有了parent，所以可以正确处理布局文件的宽高属性。然后，既然attachToRoot为true，那么根据上面的源码就会知道，这里会调用root的addView方法。而如果root是listView等，由于他们是继承自AdapterView的，看看AdapterView的addView方法： 1234567@Override public void addView(View child) &#123; throw new UnsupportedOperationException(&quot;addView(View) is not supported in AdapterView&quot;); &#125; 不资磁啊，那好吧，如果换成RecyclerView呢？还是报错了，看看源码： 1234567if (child.getParent() != null) &#123; throw new IllegalStateException(&quot;The specified child already has a parent. &quot; + &quot;You must call removeView() on the child&apos;s parent first.&quot;); &#125; 现在知道了吧，adpater里面不要用true。那么什么时候用true呢？答案是fragment。在为fragment创建布局时，如果为true，那么这个布局文件就会被添加到父activity中盛放fragment的布局中。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Hanlder]]></title>
    <url>%2F2017%2F07%2F22%2Fsource-handler%2F</url>
    <content type="text"><![CDATA[1.消息机制 Android消息机制，其实也就是Handler机制，主要用于UI线程和子线程之间交互。众所周知，一般情况下，出于安全的考虑，所有与UI控件的操作都要放在主线程及UI线程，而一些耗时操作应当放在子线程中。当在子线程中完成耗时操作并要对UI控件进行操作时，就要用Handler来控制了。在这一套消息机制中，首先要明确这样几个概念： Handler：消息的控制器 Message：消息的载体 MessageQueue:存放消息 Looper：控制消息队列的循环 （MessageQueue严格意义上说并不是一个存放消息的队列，Message本身通过next一个一个的连在一起，通过单链表形成了一个队列，MessageQueue只是可以对这个队列进行部分操作，比如入队） 下面一段简单的代码就展示了Handler的用法： 12345678910111213141516171819202122private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(&quot;对UI进行操作&quot;); &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.mytv); new Thread(new Runnable() &#123; @Override public void run() &#123; //模拟耗时操作 SystemClock.sleep(3000); handler.sendMessage(new Message()); &#125; &#125;).start(); &#125; 可以看到，在子线程中通过发送一个消息 Message，然后再由Handler处理接收到的消息，下面我将一步一步看sdk的源码了解他的原理。 2.发送消息：sendMessage 跟踪sendMessage()/sendEmptyMessage()： 12345678910111213 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0); &#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125; 可以看到，无论是sendMessage() 还是sendEmptyMessage()，最后都会调用sendMessageDelayed()方法。不同之处在于，sendMessage()方法接受的是一个Message对象，然后将这个对象传给sendMessageDelayed(),而sendEmptyMessage()需要的是一个int值what，然后通过Message.obtain()方法得到一个Mesage对象，再将what值赋给他，最后传给sendMessageDelayed()。类似的还有sendMessageAtFrontOfQueue()和sendEmptyMessageAtTime()等方法，总之就是需要一个Message对象并将他传给sendMessageDelayed(); 这里有两个点需要注意一下，第一点，what值是干什么的？第二点，new出来的Message对象和调用Message.obtain()方法得到的对象有什么区别呢？ 这是对what的描述： 1234567/** * User-defined message code so that the recipient can identify * what this message is about. Each &#123;@link Handler&#125; has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; 可见，what就是一条消息的消息代码，由于不同的handler都有自己的命名空间，所以我们不必担心会引起冲突。 再来看看obtain(): 1234567891011121314151617 /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 原来android已经为我们定义好了一个全局的Message池，这个池是一个链表型数据结构，通过obtain()方法可以从链表头取出一个Message对象。这两个小问题解决完了，继续看 sendMessageDelayed(): 123456public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 可以看到，对消息的时间做了一下修正，然后传给了sendMessageAtTime()，这里为时间加上了一个SystemClock.uptimeMillis()，也就是从这里开始，采用了系统的准确时刻而不是之前的延时多久。接下来看sendMessageAtTime(): 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 在这里首先获取了Handler中的MessageQueue对象，若不为空，说明一切正常，接下来就要将这个Message插入到MessageQueue中。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 这里将这个message的目标(target)指向了该handler自己(this)，然后调用MessageQueue的enqueueMessage()方法进行了消息的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 如果熟悉数据结构的话，可以很清楚的看到，这个所谓的消息队列MessageQueue是一个链表，将消息插入消息队列就是一个简单的对链表进行插入的过程。首先会对链表头指针做判断，如果为空，那么就把当前消息插入到链表头部，如果链表不为空，那么比较一下当前消息的执行时间，若时间小于头指针所存储的消息，那么也要将他插入到链表头部。若以上条件都不满足，那么就要对链表进行一个遍历，找到适当的位置并插入。 3.取出消息：LooperLooper负责取出消息然后把消息交给目标handler处理。那么他是怎么工作的呢，来看看他的源码：首先，Looper的入口是prepare()方法： 12345678910public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 调用prepare()方法，会new 一个Looper对象把他传给sThreadLocal.set()方法，那么先来看看这个方法是何用： 1234567891011121314151617/** * Sets the current thread&apos;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&apos;s copy of * this thread-local. */ public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 他将一个数据保存在了当前线程中。那么刚才就是将一个Looper对象保存在了调用方法的当前线程中。再来看看Looper的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 还记得默认是给构造方法传了一个值为true的boolean。在这个构造方法中，先创建了一个消息队列，保存起来，然后又获取了当前线程，并保存起来。综合一下，就是在创建Looper的时候将当前线程、一个消息队列和该Looper对象关联起来了。创建好了Looper，接下来就是开启了。开启方法是loop(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 代码太长，我只看关键部分： 12345final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; 首先通过myLooer()从当前线程中获取到了刚刚保存起来的Looper对象，然后检查是否为空。如果为空，直接抛出异常。因此，我们要想使用Looper，就要先调用prepare()方法创建一个Looper对象保存在当前线程，然后才能在loop()方法中获取到。之后进入了一个死循环中： 1234567891011121314151617for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; //...... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //...... msg.recycleUnchecked(); &#125; 在这个循环中，会不断的从queue中获取msg，然后调用msg的target的dispatchMessage()方法，queue通过名字可以看出来是一个队列，即消息队列，暂不深究。这里有一个问题，msg的target是什么？dispatchMessage()做了什么？ 1/*package*/ Handler target; 跟踪进来可以看到，target其实就是一个Handler对象，那么dispatchMessage()也即Handler的方法了： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 首先，若msg的callback不为空就调用handleCallback()方法： 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 否则，先判断自己的callback若不为空，则将msg传给mCallback的handleMessage()： 123public interface Callback &#123; public boolean handleMessage(Message msg); &#125; 最后实在不行才回去调用自己的handleMessage方法： 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 这个方法是要自己覆盖的（不然一个空方法调用个锤子）。那么现在很请除了，每一条消息关联了自己的Handler对象，然后把自己交给他去处理。还记得前面发送消息时有一行代码是Handler将target指向了自己吗？对，就是在那里进行了关联。一切都分析完了（好像很简单的样子？），总结一下： Message是消息对象，表示要具体做些什么 创建Message对象建议用obtain()方法，这样是从一个消息池中不断的取出消息来使用，避免过多的内存分配 Handler首先通过sendMessage()方法把消息发送出去 Handler发送消息最终会由MessageQueue进行一个入队的操作（消息队列即链表），与此同时会将该消息的target指向该Handler，Handler和Message的联系就在这里建立起来 Looper负责不断的从消息队列中取出消息来处理 使用Looper首先要调用prepare()方法将创建的Looper对象保存在当前线程中，之后才能通过Loop()方法取出，Looper和线程、消息队列的联系在这里建立 对于消息的处理，还是要交给Handler来做，即取出消息的target所指向的Handler，交给他处理 主线程即UI线程在一开始创建时就已经创建并开启了Looper，所以我们在主线程中使用Handler时就已经和主线程、消息队列有了联系，就不用再手动调用loop()了]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Hanlder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——事件分发机制]]></title>
    <url>%2F2017%2F07%2F22%2Fsource-view-bus%2F</url>
    <content type="text"><![CDATA[事件分发机制学习笔记通过问题来学习一个东西是很好的方法。学习Android中View的事件体系，我也通过给自己提问题，在解决问题的同时也就知道了其中原理。 0首先来几个问题起步： 什么是事件？ 什么是事件分发机制？ 在我们通过屏幕与手机交互的时候，每一次点击、长按、移动等都是一个个事件。按照面向对象的思想，这些一个个事件都被封装成了MotionEvent。分发机制就是某一个事件从屏幕传递给app视图中的各个View，然后由其中的某个View来使用这一事件或者忽略这一事件，这整个过程的控制就是分发机制了。要注意的是，事件分发机制中，事件是按一个事件序列的形式分发给View的。这一序列由 ACTION_DOWN 开始，经过一系列 ACTION_MOVE 等事件，最后以 ACTION_UP 事件结束。这一个序列中的所有事件，要么被忽略，要么就只能有一个事件能使用。要是同一个序列，比如从按下到移动这一系列的动作，不同的View都能接受的话，那整个界面就会非常混乱，而且逻辑很复杂。接下来我提出这三个问题： 某一个事件从屏幕一直传递到View上这一过程的大致流程是怎样的？ 前面说了事件分发的其实是事件序列。那么同一个序列里那么多事件，是怎样的机制只交给一个View的？ 我们平时在应用开发时，在外部给View设置的的OnClick OnLongClick 的监听，是在哪里被View处理的？ 问题一：事件传递的流程是怎样的？Android中的View是树状结构，如下图所示： 每一个Activity内部都包含一个Window用来管理要显示的视图。而Window是一个抽象类，其具体实现是 PhoneWindow类。DecovrView作为PhoneWindow的一个内部类，实际管理着具体视图的显示。他是FrameLayout的子类，盛放着我们的标题栏和根视图。我们自己写的一些列View和ViewGroup都是由他来管理的。因此事件分发的时候，顶层的这些“大View”们实际上是不会对事件有任何操作的，他们只是把事件不断的向下递交，直到我们可以使用这些事件。 所以，事件自顶向下的传递过程应该是这样的： Activity（不处理）-&gt; 根View -&gt; 一层一层ViewGroup（如果有的话） -&gt; 子View 如果传递到最后我们的子View们没有处理这一事件怎么办呢？这时候就会原路返回，最终传递给Activity。只有当Activity也没有处理这一事件时，这一事件才会被丢弃。 Activity（不处理则丢弃） &lt;- 根View &lt;- 一层一层ViewGroup（如果有的话） &lt;- 子View 具体在传递事件的时候，是由以下三个方法来控制的： dispatchTouchEvent : 分发事件 onInterceptTouchEvent : 拦截事件 onTouchEvent : 消费事件 这三个方法有一个共同点，就是他们具体是否执行了自己的功能（分发、拦截、消费）完全由自己的返回值来确定，返回true就表示自己完成了自己的功能（分发、拦截、消费）。不同之处除了功能外，还有使用的场景。dispatchTouchEvent()和onTouchEvent()这两个方法，无论是Activity ViewGroup 还是View,都会被用到。而onInterceptTouchEvent()方法因为只是为了拦截事件，那么Activity和View一个在最顶层，一个在最底层，也就没必要使用了。因此在View 和 Activity中是没有onInterceptTouchEvent()方法的。 我这里自定义几个ViewGroup和View，分别重写他们的这些方法，在重写的时候打上log。在不添加任何监听（即没有View消费事件）的条件下看一下运行结果： 点击外部ViewGroup:点击子View: 可以看到，事件分发首先由ViewGroup的dispatchTouchEvent()方法开始，先调用自己的onInterceptTouchEvent()方法判断是否拦截，返回false表示自己没有拦截，那么接下来直接把事件传给子View。子View调用自己的dispatchTouchEvent()方法进行分发，因为View没有onInterceptTouchEvent()方法，所以不存在拦截操作，因此直接将事件交给自己的onTouchEvent()方法消费。因为我的子View没有使用这个事件，因此onTouchEvent()方法直接返回了false表示自己没有消费，那么这个事件此时就算是传到底了。因为自己没有消费，因此自己就没有分发出去，那么子View的dispatchTouchEvent()方法返回false，把这个事件交还给上一层的ViewGroup。ViewGroup发现这个事件没有子View消费，那么就自己动手吧！将事件传给自己的onTouchEvent()方法消费。可是ViewGroup也没有消费，那么onTouchEvent()方法只能是再返回false了。同理，ViewGroup自己没有消费事件，因此他的dispatchTouchEvent()方法也返回了false。这段文字说得可能有点乱，那么就贴一张图来演示一下：(图中红色箭头表示事件自顶向下分发的过程，黄色则表示自底向上返回的过程) 接下来，我在子View上添加OnClick监听，再看一下点击子View时的运行结果： 乍一看，呀，怎么重复打印了两遍log?其实并不是哪里写错了。前面我说了，事件分发分发的是一个事件序列，我添加了点击事件，那么我就要消费点击事件。而点击事件其实是要分成两个事件的，即ACTION_DOWN + ACTION_UP ,只有这样才算是一次点击事件。因此打印了“两遍”log其实是先打印了ACTION_DOWN的分发流程，再打印了一遍ACTION_UP的分发流程，因此会看到最后一行打印了click事件。即，click事件是在ACTION_UP事件发生后才发生的。然后看看各个方法的返回值。果然由于我的子View明确表示要消费这个事件序列，因此从ACTION_DOWN开始的所有事件就都交给他消费了。所以子View的onTouchEvent的返回值为true，表示自己需要消费这个事件，然后他的dispatchTouchEvent也返回了true，表示这一事件被自己分发了。既然自己的子View消费了事件，ViewGroup就认为这一事件是被自己分发了，因此他的dispatchTouchEvent也就返回了true。还是来一张图更清楚一点： 最后，我在上一步的基础上，给ViewGroup的onInterceptTouchEvent()方法返回值强行改为true，表示事件传到这一层的时候就被拦截了，看一下log: 果然，虽然我要在子View消费事件，但是事件在传到子View之前就被ViewGroup拦截了，那么事件就只会由ViewGroup来消费了，所以ViewGroup就把事件传给了自己的onTouchEvent()来消费。再来一张图： 综上，事件分发的大致流程就是这样。 问题二：如何保证统一序列的事件都交给一个View来处理先上结论：在传递过程中，只要有一个View主动去消费了第一个事件（ACTION_DOWN），那么ViewGroup会将这个View保存起来，之后同一事件序列的其他事件都直接交给这个View来处理。具体怎么操作，需要看一下源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186//这是ViewGroup dispatchTouchEvent()的源码：@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; //省略前面一部分无关代码 //handled是返回的结果，表示是否被分发，默认当然是 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 判断一下是不是ACTION_DOWN，如果是的话，代表一个新的事件序列来临了 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; //要注意一下这两个方法，在这里会做一下相当于是“清零”的操作 //在这里包含了诸如mFirstTouchTarget=null这样的初始化操作 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // intercepted是用来记录是否被拦截的结果 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 没有mFirstTouchTarget，同时事件为非ACTION_DOWN，那么就算要在这里拦截了 intercepted = true; &#125; //忽略部分拦截相关的代码 //这两个对象记一下，后面会碰到 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // 这里就开始对事件类型区分了，如果是ACTION_DOWN，那么就算是一个新的事件序列开始 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; // 准备一下，接下来开始遍历自己的子View们 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; // 获取到点击的坐标，用来从子View中筛选出点击到的VIEW final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // 按从后向前的顺序开始遍历子View们 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 其实筛选只是将不合适的View们过滤掉 //一个一个continue就表示在发现View不合适的时候直接进入下一次循环 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //终于找到了合适的子View,注意这里将子View封装为一个target //要是返回的结果不为空就跳出循环 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; //就算返回结果为空也没关系，在这里继续递归的调用子View的dispatchTransformedTouchEvent() resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; if (preorderedList != null) preorderedList.clear(); &#125; //没有找到要接受事件的View if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //接下来就是对于非ACTION_DOWN事件的分发了，这里有两种情况 if (mFirstTouchTarget == null) &#123; // 1.压根就没有找到要接受事件的view，或者被拦截了，调用了自身的dispatchTransformedTouchEvent()且穿了一个null的View进去，这样有什么用呢？需要后面分析dispatchTransformedTouchEvent() handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; //2.有View接受ACTION_DOWN事件，那么这个View也将接受其余的事件 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; //alreadyDispatchedToNewTouchTarget这个变量在前面View接受ACTION_DOWN事件时设为了true //同时这个mFirstTouchTarget也就是那个View封装好的target //那么这个返回值handled就为true handled = true; &#125; else &#123; //对于非ACTION_DOWN事件，依然是递归调用dispatchTransformedTouchEvent final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 处理ACTION_UP和ACTION_CANCEL if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 接下来看看dispatchTransformedTouchEvent()的源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//前面在分析dispatchTouchEvent()的时候发现有多处调用了这个dispatchTransformedTouchEvent(),而且有的地方传来的第三个参数是nullprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //处理ACTION_CANCEL final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //忽略部分代码…… if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; //如果传来的参数child为空时，调用自身dispatchTouchEvent() handled = super.dispatchTouchEvent(event); &#125; else &#123; //不为空，那么就调用他的dispatchTouchEvent() handled = child.dispatchTouchEvent(event); &#125; return handled; &#125; &#125; else &#123; //... &#125; if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 上面是对dispatchTouchEvent()和dispatchTransformedTouchEvent()的分析，看起来有点乱，这里梳理一下： 首先明确一点，事件分发是从ViewGroup的dispatchTouchEvent()开始的 ViewGroup在遇到一个新的事件序列，即事件ACTION_DOWN时，开始遍历自己的所有子View,找到需要接收到事件的View 无论是否找到，都会调用dispatchTransformedTouchEvent()方法，区别在于如果找到了,那么在这个方法中传入的是那个View，否则就是null dispatchTransformedTouchEvent()方法中第三个参数child为空时，会调用父类的dispatchTouchEvent()方法，否则会调用那个child的dispatchTouchEvent()方法。总而言之，都会去调用View类的dispatchTouchEvent()方法。 dispatchTransformedTouchEvent()方法是进行具体的事件分发，除了OnClick()等事件外，onTouchEvent()方法就是在这里调用的 只要找到了要接受事件的View,就会将他封装为一个target,保存起来，后续的其他事件都由他来接受 问题三：OnClick OnLongClick等对外的监听是在哪里处理的？首先想一想一个很简单的逻辑，OnClick事件是先ACTION_DOWN之后再ACTION_UP,所以必定要在onTouchEvent()处理。同理，OnLongClick是在保持ACTION_DOWN一段时间后发生，因此也要在onTouchEvent()中处理。看看源码，发现果然是在这里：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//以下源码均为忽略了不想关部分，只保留了重点public boolean onTouchEvent(MotionEvent event) &#123; //... if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 处理click if (!focusTaken) &#123; if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; &#125; break; case MotionEvent.ACTION_DOWN: // a short period in case this is a scroll. if (isInScrollingContainer) &#123; //... &#125; else &#123; // 处理longclick setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); //... mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: //... break; &#125; return true; &#125; return false;&#125; 根据前面的分析，在View的dispatchTouchEvent()方法中，会对 12345678910111213141516171819202122232425262728293031public boolean dispatchTouchEvent(MotionEvent event) &#123; //... boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; //... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //只要获取到的ListenerInfo不为空，就说明我们设置了监听，那么就会认为我们想让这个View处理所有事件 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;//所以会在这里执行onTouch() result = true; &#125; //而如果没有处理，那么再调用onTouchEvent(),直到onTouchEvent()也返回false才会认为该View不消费事件 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; return result;&#125; 可以看到，在View的dispatchTouchEvent()方法中，会通过查看是否由设置监听器等方法来判断是否要消费事件。onTouchEvent()方法永远会调用，click和longclick都在这里面。而无论内部如何处理，只要返回了true，就会认为消费了这一事件。 分析就到这了，作为一个小菜鸡，分析过程难免有些错误和疏漏，欢迎在评论区告诉我]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
