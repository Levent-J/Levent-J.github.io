<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一只Android小菜鸡学习之路">
<meta property="og:type" content="website">
<meta property="og:title" content="靖然是你">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="靖然是你">
<meta property="og:description" content="一只Android小菜鸡学习之路">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="靖然是你">
<meta name="twitter:description" content="一只Android小菜鸡学习之路">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>靖然是你</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">靖然是你</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/android-inflater/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/android-inflater/" itemprop="url">Layout.inflat()中的那些坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LayoutInflater.inflate()这个方法，大家一定很熟悉——在给fragment添加布局文件，或者在RecyclerView的Adapter中为item添加布局时，都会用到。inflate()这个方法需要最多三个参数：resource，root，以及attachToRoot。参考源码，就知道了这里的resource是你具体要添加的那个布局文件，root是布局的根参数，那么attachToRoot是什么意思呢？什么时候为true，什么时候为false？</p>
<h2 id="三个参数的关系"><a href="#三个参数的关系" class="headerlink" title="三个参数的关系"></a>三个参数的关系</h2><p>参见官方文档，对这三个参数的介绍是：被填充的层是否应该附在root参数内部？如果是false，root参数只适用于为xml根元素View创建正确的LayoutParams的子类。</p>
<p>什么意思呢？就是说，如果attachToRoot为true，那么resource指定的布局文件就会依附于root指定的ViewGroup，然后这个方法就会返回root，否则，只会将resource指定的布局文件填充并将其返回，具体可以参考源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line"></span><br><span class="line">        synchronized (mConstructorArgs) &#123;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">            final Context inflaterContext = mContext;</span><br><span class="line"></span><br><span class="line">            final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line"></span><br><span class="line">            Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line"></span><br><span class="line">            mConstructorArgs[0] = inflaterContext;</span><br><span class="line"></span><br><span class="line">            View result = root;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                // Look for the root node.</span><br><span class="line"></span><br><span class="line">                int type;</span><br><span class="line"></span><br><span class="line">                while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line"></span><br><span class="line">                        type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">                    // Empty</span><br><span class="line">                if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line"></span><br><span class="line">                    throw new InflateException(parser.getPositionDescription()</span><br><span class="line"></span><br><span class="line">                            + &quot;: No start tag found!&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;Creating root view: &quot;</span><br><span class="line"></span><br><span class="line">                            + name);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line"></span><br><span class="line">                    if (root == null || !attachToRoot) &#123;</span><br><span class="line"></span><br><span class="line">                        throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line"></span><br><span class="line">                                + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    // Temp is the root view that was found in the xml</span><br><span class="line"></span><br><span class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (root != null) &#123;</span><br><span class="line"></span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line"></span><br><span class="line">                            System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line"></span><br><span class="line">                                    root);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // Create layout params that match root, if supplied</span><br><span class="line"></span><br><span class="line">                        params = root.generateLayoutParams(attrs);</span><br><span class="line"></span><br><span class="line">                        if (!attachToRoot) &#123;</span><br><span class="line"></span><br><span class="line">                            // Set the layout params for temp if we are not</span><br><span class="line"></span><br><span class="line">                            // attaching. (If we are, we use addView, below)</span><br><span class="line"></span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    // Inflate all children under temp against its context.</span><br><span class="line"></span><br><span class="line">                    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    // We are supposed to attach all the views we found (int temp)</span><br><span class="line"></span><br><span class="line">                    // to root. Do that now.</span><br><span class="line"></span><br><span class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line"></span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    // Decide whether to return the root that was passed in or the</span><br><span class="line"></span><br><span class="line">                    // top view found in xml.</span><br><span class="line"></span><br><span class="line">                    if (root == null || !attachToRoot) &#123;</span><br><span class="line"></span><br><span class="line">                        result = temp;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line"></span><br><span class="line">                InflateException ex = new InflateException(e.getMessage());</span><br><span class="line"></span><br><span class="line">                ex.initCause(e);</span><br><span class="line"></span><br><span class="line">                throw ex;</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                InflateException ex = new InflateException(</span><br><span class="line"></span><br><span class="line">                        parser.getPositionDescription()</span><br><span class="line"></span><br><span class="line">                                + &quot;: &quot; + e.getMessage());</span><br><span class="line"></span><br><span class="line">                ex.initCause(e);</span><br><span class="line"></span><br><span class="line">                throw ex;</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                // Don&apos;t retain static reference on context.</span><br><span class="line"></span><br><span class="line">                mConstructorArgs[0] = lastContext;</span><br><span class="line"></span><br><span class="line">                mConstructorArgs[1] = null;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，就是：</p>
<ul>
<li>若attachToRoot为true且root不为null，则调用root.addView()方法</li>
<li>若root为null，或者attachToRoot为false，则直接将temp赋于result(temp是通过root构造的，result就是root)</li>
</ul>
<h2 id="何时为true，何时为false"><a href="#何时为true，何时为false" class="headerlink" title="何时为true，何时为false?"></a>何时为true，何时为false?</h2><p>就拿我们的Adapter来说吧，在创建item布局时，有下列几种情况：</p>
<ul>
<li>inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,null);</li>
<li>inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,parent,false);</li>
<li>inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,parent,true);</li>
</ul>
<p>那么就讲一下这三种情况把。</p>
<p>首先，inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,null) 。这是最简单的写法，这样生成的布局就是根据R.layout.xxx返回的View。要知道，这个布局文件中的宽高属性都是相当于父布局而言的。由于没有指定parent，所以他的宽高属性就失效了，因此不管你怎么改宽高属性，都无法按你想象的那样显示。</p>
<p>然后，inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,parent,false)。相较于前者，这里加了父布局，不管后面是true还是false，由于有了parent，布局文件的宽高属性是有依靠了，这时候显示的宽高样式就是布局文件中的那样了。</p>
<p>最后，inflate(<a href="http://r.layout.xxx/" target="_blank" rel="noopener">R.layout.xxx</a>,parent,true)。这样……等等，报错了？？？哦，不要惊奇，分析一下原因：首先，有了parent，所以可以正确处理布局文件的宽高属性。然后，既然attachToRoot为true，那么根据上面的源码就会知道，这里会调用root的addView方法。而如果root是listView等，由于他们是继承自AdapterView的，看看AdapterView的addView方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">    public void addView(View child) &#123;</span><br><span class="line"></span><br><span class="line">        throw new UnsupportedOperationException(&quot;addView(View) is not supported in AdapterView&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不资磁啊，那好吧，如果换成RecyclerView呢？还是报错了，看看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (child.getParent() != null) &#123;</span><br><span class="line"></span><br><span class="line">            throw new IllegalStateException(&quot;The specified child already has a parent. &quot; +</span><br><span class="line"></span><br><span class="line">                    &quot;You must call removeView() on the child&apos;s parent first.&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>现在知道了吧，adpater里面不要用true。那么什么时候用true呢？答案是fragment。在为fragment创建布局时，如果为true，那么这个布局文件就会被添加到父activity中盛放fragment的布局中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/java-jvm-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/java-jvm-1/" itemprop="url">《深入理解JVM》读书笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机会把他所管理的内存划分为若干个不同的数据区域：</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程共享</th>
<th style="text-align:center">线程隔离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法区</td>
<td style="text-align:center">本地方法栈</td>
</tr>
<tr>
<td style="text-align:center">堆</td>
<td style="text-align:center">虚拟机栈</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">程序计数器</td>
</tr>
</tbody>
</table>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>1.程序计数器是当前线程所执行的字节码的行号指示器2.在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令3.如果正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是native方法，则计数器值为空  </p>
<h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>1.虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息2.通常所说的“Java内存分为堆内存和栈内存”是过于粗糙的，其中的栈所指的实际上是虚拟机栈，确切的说是虚拟机栈中的局部变量表3.long 和 double型的数据会占用2个局部变量空间，其余的数据类型只占用1个4.局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法在帧中要分配多大的局部变量空间是完全确定的  </p>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>1.本地方法栈和虚拟机栈的区别在于，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为Native放法服务2.有的虚拟机，如HotSpot，直接把本地方法栈和虚拟机栈合二为一  </p>
<h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h2><p>1.Java堆是Java虚拟机所管理的内存中最大的一块2.Java堆在虚拟机启动时创建，被所有线程共享3.Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里4.Java堆为了便于更好的回收和分配内存，可以细分为：“新生代和老生代”，或者“Eden\ From Survivor\ To Survivor等”5.Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可  </p>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p>1.方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据2.如何实现方法区属于虚拟机的实现细节，不受虚拟机规范约束3.方法区可以选择不实现垃圾回收4.方法区的内存回收目标主要针对常量池的回收和对类型的卸载  </p>
<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><p>1.运行时常量池用于存放编译器生成的各种字面量和符号引用2.直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域</p>
<h2 id="虚拟机对象探秘"><a href="#虚拟机对象探秘" class="headerlink" title="虚拟机对象探秘"></a>虚拟机对象探秘</h2><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h2><p>1.虚拟机在遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查该类是否已加载。如果没有加载，还要先执行相应的类加载过程2.内存分配方式有两种，选择哪种方式由Java堆是否规整决定，若规整，则采用“指针碰撞”方式，若不规整，则采用“空闲列表方式”；而是否规整又由所采用的垃圾回收机制决定3.解决并发环境下的分配内存有两种方式:  </p>
<ul>
<li>对分配内存空间的动作进行同步处理  </li>
<li>把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在堆中预先分配一小块内存（TLAB）  </li>
</ul>
<p>4.内存分配完成后还要将分配的内存空间都初始化为零值，从而保证对象的实例字段在Java代码中可以不赋初始值就直接使用5.初始化后还要给对象进行相关各设置，诸如哈希码、GC分代年龄信息等6.上述工作结束后，从虚拟机视角来看，一个新的对象已经产生了；但从Java程序的角度来看，对象的创建才刚刚开始————进行Java代码的初始化操作  </p>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h2><p>1.对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充2.对象头一搬包含两部分内容：对象的运行时数据和类型指针。如果对象是数组，则还有一个部分来记录数组的长度3.运行时数据指哈希码、GC分代年龄等信息，被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，会根据对象的状态复用自己的存储空间4.类型指针是对象指向他的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例5.实例数据是对象真正存储的有效信息，即程序中的字段内容6.实例数据默认的分配策略是按顺序，相同宽度的字段总是分配在一起7.对齐填充不是必然的，仅仅起着占位符的作用8.对象的大小必须是8字节的整数倍，对象头部分正好是8字节的倍数  </p>
<h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h2><p>1.Java程序通过栈上的reference数据来操作堆上的具体对象2.对象的访问形式取决于虚拟机，目前主流的有两种方式：使用句柄  和  直接指针3.使用句柄是间接访问，优点是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针4.使用直接指针是直接访问，优点就是速度快</p>
<h2 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h2><h2 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1.Java堆溢出"></a>1.Java堆溢出</h2><p>1.Java堆用于存储对象实例，只要不断的创建对象，且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制之后就会产生内存溢出的异常  </p>
<h2 id="2-虚拟机和本地方法栈的溢出"><a href="#2-虚拟机和本地方法栈的溢出" class="headerlink" title="2.虚拟机和本地方法栈的溢出"></a>2.虚拟机和本地方法栈的溢出</h2><p>1，HotSpot虚拟机中并不区分虚拟机栈和本地方法栈2.关于虚拟机栈和本地方法栈，Java虚拟机规范中描述了量中异常：  </p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常  </li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常3.在单个线程下，无论是由于栈太小还是虚拟机栈容量太小，当内存无法分配时，虚拟机抛出的都是StackOverflowError异常  3.方法区和运行时常量池溢出</li>
</ul>
<p>2..在JDK 1.6中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用2.在JDK 1.7中 intern() 方法不会再复制实例，只是在常量池中记录首次出现的实例引用  </p>
<p>3.StringBuilder 创建的字符串实例在Java堆上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/java-jvm-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/java-jvm-4/" itemprop="url">《深入理解JVM》读书笔记（四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三部分-虚拟机执行子系统"><a href="#第三部分-虚拟机执行子系统" class="headerlink" title="第三部分 虚拟机执行子系统"></a>第三部分 虚拟机执行子系统</h1><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1.类加载的时机"></a>1.类加载的时机</h3><p>1.类从被加载到虚拟机内存开始，到卸载出内存为止，他的整个生命周期包括：加载-验证-准备-解析-初始化-使用-卸载 七个阶段，其中验证、准备、解析三个部分统称为链接。<br>2.加载的时机：</p>
<ul>
<li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、以及调用一个类的静态方法的时候。</li>
<li>使用reflect包中的方法进行反射调用的时候，若类没有进行过初始化，则需要先出发其初始化</li>
<li>初始化一个类，发现他的父类还没有被初始化时，要先触发其父类的初始化</li>
<li>虚拟机启动时，需要指定一个main类作为入口，虚拟机会优先初始化这个类</li>
<li>使用动态语言支持时  </li>
</ul>
<p>3.以上五个场景都是属于主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用。<br>4.当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不会要求其父类接口全部初始化，只有在真正使用到父类接口的时候才会初始化。</p>
<h3 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2.类加载的过程"></a>2.类加载的过程</h3><p>1.加载：加载是类加载过程的一个阶段，在这一阶段需要完成以下三件事：  </p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的Clas对象没座位方法区这个类的各种数据的访问入口</li>
</ul>
<p>加载阶段和链接阶段的一部分内容是交叉运行的，这些加载加载阶段之中执行的动作，仍然属于链接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。  </p>
<p>2.验证：验证是链接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全，因此验证是虚拟机对自身保护的一项重要工作。</p>
<p>从整体上看，验证阶段有以下四个阶段：  </p>
<ul>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机理解  </li>
<li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述信息符合Java语言规范的要求。</li>
<li>字节码验证：通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的</li>
<li>符号引用验证：对类自身以外的信息进行匹配性教研，确保解析动作能正常执行<br>3.准备：准备阶段是正式为类变量分配内存并设置类变量初始值阶段。这些变量所使用的内存都在方法区中分配。这个时候设的初值依据不同机器而言，都是零值，在初始化阶段之后才会赋予自己定义的初值。  </li>
</ul>
<p>4.解析：虚拟机将常量池中的引用替换为直接引用。所谓符号引用，是指用一组符号来描绘所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符。</p>
<p>5.初始化：这是类加载过程的最后一步。前面的加载过程都是虚拟机主导和控制的，到了初始化阶段才真正开始执行类中定义的程序代码（字节码）。<br>  在准备阶段已经有过一次赋值了，那个初始值是根据不同机器来取的零值。而在初始化阶段，相当于是执行了类的构造器的过程。</p>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h3><p>  1.通过一个类的全限定名来获取描述此类的二进制字节流这一动作是放在虚拟机外部去实现的，实现这一动作的代码模块称为“类加载器”</p>
<p>  2.对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。 </p>
<p>  3.从Java虚拟机的角度来讲，只存在两种不同的类加载器：  </p>
<ul>
<li>启动类加载器：由C++实现，是虚拟机的一部分<ul>
<li>所有其他类加载器：由Java实现，独立于虚拟机外部，全都继承自ClassLoader类。  </li>
</ul>
</li>
</ul>
<p>4.从Java开发人员的角度来看，类加载器分为：</p>
<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器  </li>
</ul>
<p>5.我们的应用程序都是由这三种类加载器互相配合进行加载的，她们之间的关系采用了双亲委派模型，这一模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是那这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成工作时，子加载器才会尝试自己去加载。</p>
<h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><p>首先，所有Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h3 id="运行时栈帧"><a href="#运行时栈帧" class="headerlink" title="运行时栈帧"></a>运行时栈帧</h3><p>1.栈帧：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。<br>2.每一个栈帧都包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息，在编译的时候内存就已经分配好了，不会收到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。<br>3.一个线程中的方法调用链很长，所以栈里面有很多栈帧，而只有位于栈顶的那个栈帧才是当前有效的，称为当前栈帧。  </p>
<h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>1.局部变量表：一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以Slot为最小单位，一个Slot可以存放一个32位以内的数据类型，对于64位的数据类型，虚拟机回以高位对齐的方式为其分配两个连续的Slot空间 。虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。  </p>
<p>2.操作数栈：也称为操作栈，在方法的执行过程中，会有各种字节码指令往操作栈中写入和提取内容。操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配。在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但在大多数虚拟机的实现中会做一些优化处理，即让两个栈帧出现一部分重叠，让下面占帧的部分操作数栈与上面栈帧的部分局部表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数复制传递。</p>
<p>3.动态链接：一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用的作用是为了支持方法调用过程中的动态链接。class文件中的常量池中存在很多符号引用，字节码中的方法调用指令就以常量池中指向方法符号引用作为参数，这些富豪引用一部分将在每一次运行期间转化为直接引用，这种转化称为静态解析，另一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。</p>
<p>4.方法返回地址：当一个方法执行后，只有两种方式可以退出这个方法，第一种方式是执行引擎遇到一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型讲根据遇到何种方法返回指令来决定，这种退出方式称为正常完成出口。  </p>
<p>另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体中得到处理导致方法退出，这种退出方式称为异常完成出口，一个方法使用异常完成初九的方式退出，是不会给他的上层调用者产生任何返回值。无论采用何种方式退出，都要返回到被调用的位置。    </p>
<ul>
<li>正常退出：调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数值  </li>
<li>异常退出：返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li>
</ul>
<p>5.附加信息：一些规范里没有描述的信息，例如调试相关的信息等</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。</p>
<p>1.解析：所有方法调用中的目标方法子Class文件里都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这总解析用来处理静态方法和私有方法。前者与类型直接相关，后者在外部不可被访问，因此他们都不可在其他地方被继承或重写</p>
<p>2.分派：Java的三个特性：继承、封装、多态，其中在多态特性中的体现–重载和重写，是由分派决定的。分派由静态分派和动态分派。每一个对象在创建时都有一个静态类型和一个实际类型。静态类型和实际类型在程序运行期间都可以发生一些变化，区别在于静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，且最终的静态类型是在编译器可知的。而实际类型变化的结果在运行期才可确定，编译器在编译时并不知道一个对象的实际类型是什么。虚拟机在重载时是通过参数的静态类型作为判定依据的，依据静态类型分派的方式称为静态分派，体现在方法重载，而动态分派体现在方法重写。动态分派的方法版本选择过程最常用的优化方法是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。需方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那么子类中的虚方法表里面的地址入口和父类相同的方法的地址入口是一致的，如果重写了这个方法，那么方法入口地址将会代替入口地址</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/android-handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/android-handler/" itemprop="url">Android消息机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-消息机制"><a href="#1-消息机制" class="headerlink" title="1.消息机制"></a>1.消息机制</h2><p> Android消息机制，其实也就是Handler机制，主要用于UI线程和子线程之间交互。众所周知，一般情况下，出于安全的考虑，所有与UI控件的操作都要放在主线程及UI线程，而一些耗时操作应当放在子线程中。当在子线程中完成耗时操作并要对UI控件进行操作时，就要用Handler来控制了。在这一套消息机制中，首先要明确这样几个概念：  </p>
<ul>
<li>Handler：消息的控制器  </li>
<li>Message：消息的载体  </li>
<li>MessageQueue:存放消息</li>
<li>Looper：控制消息队列的循环   </li>
</ul>
<p>（经评论区小伙伴指正，MessageQueue严格意义上说并不是一个存放消息的队列，Message本身通过next一个一个的连在一起，通过单链表形成了一个队列，MessageQueue只是可以对这个队列进行部分操作，比如入队）</p>
<p>下面一段简单的代码就展示了Handler的用法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Handler handler = new Handler()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">         super.handleMessage(msg);</span><br><span class="line">         textView.setText(&quot;对UI进行操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       textView = (TextView) findViewById(R.id.mytv);</span><br><span class="line">       new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               //模拟耗时操作</span><br><span class="line">               SystemClock.sleep(3000);</span><br><span class="line">               handler.sendMessage(new Message());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，在子线程中通过发送一个消息 Message，然后再由Handler处理接收到的消息，下面我将一步一步看sdk的源码了解他的原理。  </p>
<h2 id="2-发送消息：sendMessage"><a href="#2-发送消息：sendMessage" class="headerlink" title="2.发送消息：sendMessage"></a>2.发送消息：sendMessage</h2><p> 跟踪sendMessage()/sendEmptyMessage()：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public final boolean sendMessage(Message msg)&#123;</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean sendEmptyMessage(int what)&#123;</span><br><span class="line">        return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    return sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，无论是sendMessage() 还是sendEmptyMessage()，最后都会调用sendMessageDelayed()方法。不同之处在于，sendMessage()方法接受的是一个Message对象，然后将这个对象传给sendMessageDelayed(),而sendEmptyMessage()需要的是一个int值what，然后通过Message.obtain()方法得到一个Mesage对象，再将what值赋给他，最后传给sendMessageDelayed()。类似的还有sendMessageAtFrontOfQueue()和sendEmptyMessageAtTime()等方法，总之就是需要一个Message对象并将他传给sendMessageDelayed();    这里有两个点需要注意一下，第一点，what值是干什么的？第二点，new出来的Message对象和调用Message.obtain()方法得到的对象有什么区别呢？  这是对what的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * User-defined message code so that the recipient can identify</span><br><span class="line">    * what this message is about. Each &#123;@link Handler&#125; has its own name-space</span><br><span class="line">    * for message codes, so you do not need to worry about yours conflicting</span><br><span class="line">    * with other handlers.</span><br><span class="line">    */</span><br><span class="line">   public int what;</span><br></pre></td></tr></table></figure>
<p> 可见，what就是一条消息的消息代码，由于不同的handler都有自己的命名空间，所以我们不必担心会引起冲突。  再来看看obtain():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Return a new Message instance from the global pool. Allows us to</span><br><span class="line"> * avoid allocating new objects in many cases.</span><br><span class="line"> */</span><br><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来android已经为我们定义好了一个全局的Message池，这个池是一个链表型数据结构，通过obtain()方法可以从链表头取出一个Message对象。这两个小问题解决完了，继续看 sendMessageDelayed():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对消息的时间做了一下修正，然后传给了sendMessageAtTime()，这里为时间加上了一个SystemClock.uptimeMillis()，也就是从这里开始，采用了系统的准确时刻而不是之前的延时多久。接下来看sendMessageAtTime():   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    if (queue == null) &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里首先获取了Handler中的MessageQueue对象，若不为空，说明一切正常，接下来就要将这个Message插入到MessageQueue中。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">        msg.target = this;</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里将这个message的目标(target)指向了该handler自己(this)，然后调用MessageQueue的enqueueMessage()方法进行了消息的插入操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">                // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">                // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; // invariant: p == prev.next</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果熟悉数据结构的话，可以很清楚的看到，这个所谓的消息队列MessageQueue是一个链表，将消息插入消息队列就是一个简单的对链表进行插入的过程。首先会对链表头指针做判断，如果为空，那么就把当前消息插入到链表头部，如果链表不为空，那么比较一下当前消息的执行时间，若时间小于头指针所存储的消息，那么也要将他插入到链表头部。若以上条件都不满足，那么就要对链表进行一个遍历，找到适当的位置并插入。  </p>
<h2 id="3-取出消息：Looper"><a href="#3-取出消息：Looper" class="headerlink" title="3.取出消息：Looper"></a>3.取出消息：Looper</h2><p>Looper负责取出消息然后把消息交给目标handler处理。那么他是怎么工作的呢，来看看他的源码：首先，Looper的入口是prepare()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">        prepare(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用prepare()方法，会new 一个Looper对象把他传给sThreadLocal.set()方法，那么先来看看这个方法是何用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>他将一个数据保存在了当前线程中。那么刚才就是将一个Looper对象保存在了调用方法的当前线程中。再来看看Looper的构造方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还记得默认是给构造方法传了一个值为true的boolean。在这个构造方法中，先创建了一个消息队列，保存起来，然后又获取了当前线程，并保存起来。综合一下，就是在创建Looper的时候将当前线程、一个消息队列和该Looper对象关联起来了。创建好了Looper，接下来就是开启了。开启方法是loop():  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">     * Run the message queue in this thread. Be sure to call</span><br><span class="line">     * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line">     */</span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        // Make sure the identity of this thread is that of the local process,</span><br><span class="line">        // and keep track of what that identity token actually is.</span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">            final Printer logging = me.mLogging;</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long traceTag = me.mTraceTag;</span><br><span class="line">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Make sure that during the course of dispatching the</span><br><span class="line">            // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            if (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码太长，我只看关键部分：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br></pre></td></tr></table></figure>
<p>首先通过myLooer()从当前线程中获取到了刚刚保存起来的Looper对象，然后检查是否为空。如果为空，直接抛出异常。因此，我们要想使用Looper，就要先调用prepare()方法创建一个Looper对象保存在当前线程，然后才能在loop()方法中获取到。之后进入了一个死循环中：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //......</span><br><span class="line">            try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //......</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在这个循环中，会不断的从queue中获取msg，然后调用msg的target的dispatchMessage()方法，queue通过名字可以看出来是一个队列，即消息队列，暂不深究。这里有一个问题，msg的target是什么？dispatchMessage()做了什么？    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*package*/ Handler target;</span><br></pre></td></tr></table></figure>
<p>跟踪进来可以看到，target其实就是一个Handler对象，那么dispatchMessage()也即Handler的方法了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Handle system messages here.</span><br><span class="line">     */</span><br><span class="line">    public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，若msg的callback不为空就调用handleCallback()方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>否则，先判断自己的callback若不为空，则将msg传给mCallback的handleMessage()：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">        public boolean handleMessage(Message msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后实在不行才回去调用自己的handleMessage方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Subclasses must implement this to receive messages.</span><br><span class="line">     */</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是要自己覆盖的（不然一个空方法调用个锤子）。那么现在很请除了，每一条消息关联了自己的Handler对象，然后把自己交给他去处理。还记得前面发送消息时有一行代码是Handler将target指向了自己吗？对，就是在那里进行了关联。一切都分析完了（好像很简单的样子？），总结一下：  </p>
<ul>
<li>Message是消息对象，表示要具体做些什么  </li>
<li>创建Message对象建议用obtain()方法，这样是从一个消息池中不断的取出消息来使用，避免过多的内存分配    </li>
<li>Handler首先通过sendMessage()方法把消息发送出去   </li>
<li>Handler发送消息最终会由MessageQueue进行一个入队的操作（消息队列即链表），与此同时会将该消息的target指向该Handler，Handler和Message的联系就在这里建立起来  </li>
<li>Looper负责不断的从消息队列中取出消息来处理  </li>
<li>使用Looper首先要调用prepare()方法将创建的Looper对象保存在当前线程中，之后才能通过Loop()方法取出，Looper和线程、消息队列的联系在这里建立  </li>
<li>对于消息的处理，还是要交给Handler来做，即取出消息的target所指向的Handler，交给他处理  </li>
<li>主线程即UI线程在一开始创建时就已经创建并开启了Looper，所以我们在主线程中使用Handler时就已经和主线程、消息队列有了联系，就不用再手动调用loop()了    </li>
</ul>
<p>以上就是我在学习Android消息机制及Handler时阅读SDK源码的过程，欢迎多多交流</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/java-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/java-proxy/" itemprop="url">动态代理&静态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代理，就是对类做一个包装，通过使用这个包装好的类来使用本来要用的类，这样可以额外做一些操作。<br>代理分为静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><pre><code>实现起来很简单，一个接口用来提供要实现的方法，一个被代理类和一个代理类都要实现这个接口。同时，被代理类实现接口的方法后要做自己要做的事，而代理类则要在内部创建一个被代理类的实例，然后在实现的接口的方法中调用被代理类的那个方法，同时做一些自己的修饰。
</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>不同于静态代理，动态代理的需求是当前有很多很多被代理类，要采用类似的代理方式。这个时候就要采用动态代理了。同样要定义接口及被代理类，区别在于代理类是通过反射动态生成的。具体：实现InvocationHandler这个接口，持有一个被代理类的对象object，然后实现：<br>/**</p>
<pre><code> * 返回代理对象
 * @return
 */
public Object newProxyInstance() {
    return Proxy.newProxyInstance(proxied.getClass().getClassLoader(), proxied.getClass().getInterfaces(), this);
}
</code></pre><p>这个方法是用来获得代理的对象。然后最重要的是要实现：<br>/**</p>
<pre><code> * 
 * @param proxy 代理对象
 * @param method 代理方法
 * @param args 方法参数
 * @return
 * @throws Throwable
 */
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 
    //将代理对象生成字节码到F盘上，方便反编译出java文件查看，实际动态代理是不需要自己生成的
    addClassToDisk(proxy.getClass().getName(), ProxyClassImpl.class,&quot;F:/$Proxy0.class&quot;);
    System.out.println(&quot;method:&quot;+method.getName());  
    System.out.println(&quot;args:&quot;+args[0].getClass().getName());  
    System.out.println(&quot;Before invoke method...&quot;);  
    Object object=method.invoke(proxied, args);
    System.out.println(&quot;After invoke method...&quot;);  
    return object;  
</code></pre><p>这个方法是用来调用构造器的。具体使用时，我们不需要使用invoke方法，只是：<br>1.获得被代理类的一个对象，传给handler来获得代理类<br>2.调用handler的newInstance方法获取一个代理类对象<br>3.这个时候已经生成好了代理类，我们可以直接用这个代理对象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/java-jvm-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/java-jvm-5/" itemprop="url">《深入理解JVM》读书笔记（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第五部分-高效并发"><a href="#第五部分-高效并发" class="headerlink" title="第五部分 高效并发"></a>第五部分 高效并发</h1><p>这一部分主要讲了Java内存模型与线程相关</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>何为内存模型？首先我们知道，Java是跨平台的，怎么实现跨平台呢？是因为虚拟。虚拟机怎么就跨平台了呢？是因为Java虚拟机定义了一种内存模型，用来屏蔽掉各种硬件和操作系统的内存访问差异，这样就让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<h3 id="1-主存与工作内存"><a href="#1-主存与工作内存" class="headerlink" title="1.主存与工作内存"></a>1.主存与工作内存</h3><p>1.Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。（此处的变量不是单纯的指Java语言中定义的变量，塔包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数）</p>
<p>2.Java内存模型规定了所有变量都存储在主内存中，除此之外每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。</p>
<p>3.这里所讲的主内存、工作内存和Java内存区域中所谓的堆、栈、方法区并不是一个层次的内容。</p>
<p>4.所谓的java内存模型，是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特性来建立的。</p>
<h3 id="2-内存间交互操作"><a href="#2-内存间交互操作" class="headerlink" title="2.内存间交互操作"></a>2.内存间交互操作</h3><p>1.主内存与工作内存间的交互协议，有以下八种操作。这其中的每一种操作都是原子性的，不可再分的。</p>
<ul>
<li>lock：作用于主存，把一个变量标识为线程独占状态</li>
<li>unlock：作用于主存，把一个被lock的变量释放出来</li>
<li>read：作用于主存，把一个变量的值从主存传输到工作内存</li>
<li>load：作用于工作内存，把read读到的变量值放入到工作内存的变量副本中</li>
<li>use：作用于工作内存，把变量的值传递给执行引擎</li>
<li>assign：作用于工作内存，把从执行引擎接收到的值赋给变量</li>
<li>store：作用于工作内存，把变量的值传送到主存中</li>
<li>write：作用于主存，把工作内存得到的变量的值放入到主存</li>
</ul>
<p>2.针对这八中操作，有以下八种规则：</p>
<ul>
<li>read和load，store和write操作之一不能单独出现</li>
<li>不允许线程丢弃最近assign操作</li>
<li>不允许线程无原因的把数据从线程工作内存同步到主存中</li>
<li>一个变量只能在主存中诞生</li>
<li>一个变量同一时刻只能有一个线程clock</li>
<li>一个变量clock会清空工作内存中此变量的值</li>
<li>没有clock就不能unclock</li>
<li>unclock之前一定要先把此变量同步到主存中</li>
</ul>
<h3 id="3-volatile特殊规则"><a href="#3-volatile特殊规则" class="headerlink" title="3.volatile特殊规则"></a>3.volatile特殊规则</h3><p>1.当一个变量被volatile定义后，便有了以下两个特性：可见性和禁止指令重排</p>
<p>2.可见性是指：当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p>
<p>3.volatile定义的变量并不是说不存在一致性。相反，在多线程环境下也可能有不一致的情况。volatile变量只能保持其可见性，在不符合以下条件时，仍然需要通过锁机制来保证一致性：</p>
<ul>
<li>运算结果不依赖变量的当前值</li>
<li>只有单一线程操作</li>
<li>变量不需要与其他状态变量共同参与不变约束</li>
</ul>
<p>4.普通的变量只会保证执行的结果是正确的，而不在乎指令执行的顺序如何，因此在多线程环境下，极端情况会出现问题</p>
<p>5.从硬件架构上说，指令重排是指CPU采用了允许将多条指令不按程序规定而顺序分开发送给各相应的电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的处理结果。</p>
<p>6.volatile读操作的性能消耗和普通变量几乎没有差异，但是写操作会慢一些，因为他要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。尽管如此，在大多数情况下，volatile的总开销还是要比锁要低很多。</p>
<p>总结：对于volatile和锁，处于对性能的考虑，只有在volatile的语义无法满足时才应该选择锁。</p>
<h3 id="4-原子性-可见性-有序性"><a href="#4-原子性-可见性-有序性" class="headerlink" title="4.原子性 可见性 有序性"></a>4.原子性 可见性 有序性</h3><ul>
<li>原子性：由Java内存模型来保证具有原子性的是基本数据类型（除long double因其长度特性因此不是原子性）外，还有用synchronized修饰的代码同步块。</li>
<li>可见性：可见性是指一个变量的值被修改后，其他线程能立刻得知这一个修改及获得新的值。java通过volatile来确保可见性。</li>
<li>有序性：简单概括为，在本线程内观察，所有线程都是有序的。在另一个线程中观察，所有操作都是乱的。</li>
</ul>
<h3 id="5-先行发生原则"><a href="#5-先行发生原则" class="headerlink" title="5.先行发生原则"></a>5.先行发生原则</h3><p>1.先行发生规则很重要，他是判断数据是否存在竞争、线程是否安全的主要依据。</p>
<p>2.先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，也就是说在操作B之前发生，操作A产生的影响能被操作B观察到。这里的影响是包括内存中共享变量的值、发送了消息、调用了方法。</p>
<p>3.时间先后顺序和先行发生原则之间基本没有太大关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准</p>
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="1-线程的实现"><a href="#1-线程的实现" class="headerlink" title="1.线程的实现"></a>1.线程的实现</h3><p>实现线程有以下三种方式：</p>
<ul>
<li>使用内核线程实现：直接由操作系统内核支持，由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责江线程的任务映射到各个处理器上。程序要使用的是操作系统内核提供的高级接口——轻量级进程。</li>
<li>使用用户线程实现：从广义上讲，只要不是内核线程，就是用户线程。狭义上讲用户线程指完全建立在用户空间的线程库上，系统内核不能感知线程存在。这是一种1：N的关系</li>
<li>用户线程和轻量级进程混合实现：用户线程完全建立在用户空间中，操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁</li>
</ul>
<p>优缺点：</p>
<table>
<thead>
<tr>
<th></th>
<th>优</th>
<th>劣</th>
</tr>
</thead>
<tbody>
<tr>
<td>内核线程</td>
<td>一个进程的阻塞不会影响其他进程</td>
<td>所有操作都要系统调用，代价高，要消耗一定的内核资源</td>
</tr>
<tr>
<td>用户线程</td>
<td>不需要系统内核支持</td>
<td>所有线程操作均需要用户手动完成</td>
</tr>
<tr>
<td>混合</td>
<td>兼具两者有点</td>
<td>实现复杂</td>
</tr>
</tbody>
</table>
<p>2.java线程的实现：在jdk1.2之前是由用户线程实现的。之后转为由操作系统原生线程模型实现。因此现在操作系统支持什么样的线程，很大程度上就决定了jvm的线城实现。</p>
<h3 id="2-Java线程调度"><a href="#2-Java线程调度" class="headerlink" title="2.Java线程调度"></a>2.Java线程调度</h3><p>1.线程调度是指系统为线程分配处理器使用权的过程，主要有两种：协同式和抢占式。</p>
<ul>
<li>协同：执行时间由线程本身来控制，实现简单，没有线程同步问题，但是时间不可控，会产生阻塞</li>
<li>抢占：由系统分配时间，实现复杂，会产生同步问题，执行时间可控，不会产生阻塞</li>
</ul>
<p>Java使用了抢占式调度</p>
<p>2.虽然是由系统调度执行，但也可以通过用户设置优先级的方式来做改动。</p>
<p>3.虽然可以通过设置优先级调度，但由于线程终究还是映射到系统原生线程上来实现，所以最终调度还是取决于系统，而系统线程优先级和Java又不一定一一对应，因此优先级还是不太靠谱的。</p>
<h3 id="3-状态转换"><a href="#3-状态转换" class="headerlink" title="3.状态转换"></a>3.状态转换</h3><p>Java定义了线程有五种状态：</p>
<ul>
<li>新建：创建后未运行</li>
<li>运行：可能正在执行，也可能正在等待分配时间</li>
<li>无限期等待：不会被分配时间，要等待直到被其他线程唤醒</li>
<li>限期等待：也不会分配时间，不过不用等待其他线程唤醒，只要等到一定时间之后就会由系统自动唤醒</li>
<li>阻塞：阻塞状态与等待状态的区别在于，阻塞是在等待着获得一个锁，这个锁由其他线程释放。等待指示由其他线程唤醒。</li>
<li>结束：线程已经结束执行</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/java-jvm-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/java-jvm-3/" itemprop="url">《深入理解JVM》读书笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T12:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h2 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h2><h2 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h2><p>1.主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。  </p>
<h2 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h2><p>1.主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的2.从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的3.在Java语言中，可作为GC Roots的对象包括一下四种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象  </li>
<li>方法区中类静态属性引用的对象  </li>
<li>方法区中常亮引用的对象  </li>
<li>本地方法栈中JNI引用的对象  </li>
</ul>
<h2 id="3-再谈引用"><a href="#3-再谈引用" class="headerlink" title="3.再谈引用"></a>3.再谈引用</h2><p>1.Java的引用可以分为强引用、软引用、弱引用、虚引用：  </p>
<ul>
<li>强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象  </li>
<li>软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常  </li>
<li>弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象  </li>
<li>虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例  </li>
</ul>
<h2 id="4-生存还是死亡"><a href="#4-生存还是死亡" class="headerlink" title="4.生存还是死亡"></a>4.生存还是死亡</h2><p>1.要真正宣告一个对象死亡，需要两个标记过程：</p>
<ul>
<li>若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法  </li>
<li>finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记  </li>
</ul>
<p>2.当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行  </p>
<h2 id="5-回收方法区"><a href="#5-回收方法区" class="headerlink" title="5.回收方法区"></a>5.回收方法区</h2><p>1.永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类2.类需要同时满足一下三个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，即Java堆中不再有该类的实例  </li>
<li>加载该类的ClassLoader已经被回收  </li>
<li>该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法  </li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h2 id="1-标记-清楚算法"><a href="#1-标记-清楚算法" class="headerlink" title="1.标记-清楚算法"></a>1.标记-清楚算法</h2><p>1.算法分为两个阶段：标记和清除  </p>
<ul>
<li>标记：标记所有需要回收的对象  </li>
<li>清除：统一回收所有被标记的对象  </li>
</ul>
<p>2.优点:简单，是后面其他算法的基础3.缺点：标记和清除的效率很低；标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后遇到大对象的时候无法找到足够的内存  </p>
<h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>1.思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分2.优点：实现简单，运行高效3.缺点：代价是将内存缩小了一部分，而且可能会需要额外的担保空间  </p>
<h2 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h2><p>1.思路：标记过程和标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有活着的对象向一端移动，然后直接清理掉端边界以外的内存  </p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p>1.当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为新生代和老生代，根据各个年代采用适当的收集算法2.新生代一般采用复制算法，老生代一搬采用 标记-清理 或者标记-整理 进行回收  </p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h2 id="1-枚举根节点"><a href="#1-枚举根节点" class="headerlink" title="1.枚举根节点"></a>1.枚举根节点</h2><p>1.目前主流的Java虚拟机使用的都是准确式GC，当执行系统停顿下来后并不需要一个不漏的检查完所有执行上下文和全局的引用变量，虚拟机应当有办法直接得知哪些地方存着对象的引用2.HotSpot使用一组称为OopMap的数据结构来记录哪些地方存着对象的引用3.在类加载过程中，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中会在特定的位置记录下栈和寄存器中哪些位置是引用  </p>
<h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2.安全点"></a>2.安全点</h2><p>1.HotSpot没有为每条指令都生成OopMap，只是在特定位置记录了这些信息，这些位置称为安全点2.程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停3.给多线程记录安全点时有两种方案：抢先式中断 和 主动式中断4.主动式中断的思想是当GC需要中断线程时不直接对线程进行操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起  </p>
<h2 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3.安全区域"></a>3.安全区域</h2><p>1.为了处理“不执行”的程序的安全点问题，提出了安全区域来解决问题2.安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域内的任何地方进行GC都是安全的3.虚拟机如歌具体的进行内存回收是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器  </p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul>
<li>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现  </li>
<li>不同的收集器应用的区域不同，到现在为止没有最好的收集器，也没有万能的收集器  </li>
</ul>
<h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h2><p>1.Serail收集器是“单线程”的，他在进行垃圾收集时必须暂停其他的所有线程，直到收集结束2.随着收集器的发展，用户线程的停顿时间越来越段，但任然无法消除3.Serial收集器是虚拟机运行在Client模式下默认的新生代收集器4.对于单个CPU坏境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集，可以获得很高的单线程收集效率  </p>
<h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h2><p>1.ParNew收集器是Serial收集器的多线程版本2.ParNew收集器是运行在Server模式下虚拟机中首选的新生代收集器3.在垃圾收集器中“并发”与“并行”的概念：</p>
<ul>
<li>并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态  </li>
<li>并发：用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上</li>
</ul>
<h2 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h2><p>1.Parallel Scavenge收集器是一个新生代收集器，采用复制算法2.Parallel Scavenge收集器的特点是他的关注点与其他收集器不同。其他收集器的目标是尽可能的缩短用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量3.高吞吐量可以高效的利用CPU时间，尽快得完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务4.GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的5.Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器  </p>
<h2 id="4-Serail-Old收集器"><a href="#4-Serail-Old收集器" class="headerlink" title="4.Serail Old收集器"></a>4.Serail Old收集器</h2><p>1.Serial Old收集器是Serail收集器的老年代版本，是一个单线程收集器，使用标记-整理算法2.Serail Old收集器主要用于Clinet模式下3.Serail Old收集器另一种用途是作为CMS收集器的后备预案  </p>
<h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法2，在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器  </p>
<h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h2><p>1.CMS收集器是一种以获取最短的回收停顿时间为目标的收集器2.CMS收集器基于标记-清楚算法实现，分为四个步骤：初始标记、并发标记、重新标记、并发清除3.步骤详解：</p>
<ul>
<li>初始标记：标记一下GC Roots能直接关联到的对象，速度很快  </li>
<li>并发标记：进行GC Roots Tracing  </li>
<li>重新标记：是为了修正那些在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，在这一阶段的停顿时间会比初始标记阶段稍长一点  </li>
</ul>
<p>4.从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的5.CMS收集器的缺点：  </p>
<ul>
<li>CMS收集器对CPU资源非常敏感  </li>
<li>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full FC的产生  </li>
<li>由于CMS收集器采用了标记-清除算法，所以在回收结束时会有大量空间碎片产生，碎片过多时，在给大对象分配内存时会有很大麻烦  </li>
</ul>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h2><p>1.G1收集器是一款面向服务端应用的垃圾收集器2.G1收集器具备以下特点：  </p>
<ul>
<li>并行与并发  </li>
<li>分代收集</li>
<li>空间整合：从整体上来看是基于“标记-整理”算法实现的，在局部上是基于复制算法实现的  </li>
<li>可预测的停顿   </li>
</ul>
<p>3.G1收集器将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔的了，他们是一部分Region的集合4.G1收集器可以有计划地避免在整个Java堆中进行全区域的垃圾收集：跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region5.在G1收集器中，使用Remembered Set来避免全堆扫描   </p>
<h2 id="内存分配与回收的策略"><a href="#内存分配与回收的策略" class="headerlink" title="内存分配与回收的策略"></a>内存分配与回收的策略</h2><p>对象的内存分配，往大方向讲，就是在堆上分配，主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况也可能会直接分配在老年代中，具体的分配规则取决于虚拟机自己的设置  </p>
<h2 id="1-对象优先在Eden区分配"><a href="#1-对象优先在Eden区分配" class="headerlink" title="1.对象优先在Eden区分配"></a>1.对象优先在Eden区分配</h2><p>1.大多数情况下，对象优先在新生代的Eden区分配2.当Eden区没有足够的空间时，虚拟机将发起一次Minor GC3.Minor GC与Full GC：</p>
<ul>
<li>Minor GC：新生代GC，非常频繁，回收速度快  </li>
<li>Fulll GC：老年代GC，又称为Major GC，经常会伴随一次Minor GC，速度比较慢  </li>
</ul>
<h2 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h2><p>1.大对象是指需要大量连续的内存空间的Java对象2.虚拟机提供了一个参数：PretenureSizeThreshold，大于这个参数的对象将直接在老年代分配  </p>
<h2 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3.长期存活的对象将进入老年代"></a>3.长期存活的对象将进入老年代</h2><p>1.虚拟机给每个对象定义了一个对象年龄计数器（Age），对象每经过一次Minor GC后仍然存活，且能被Survivor容纳的话，年龄就 +1 ，当年龄增加到一定程度（默认为15），就会被晋升到老年代中，这个阈值可以通过参数 MaxTenuringThreshold 来设置  </p>
<h2 id="4-动态对象年龄的判定"><a href="#4-动态对象年龄的判定" class="headerlink" title="4.动态对象年龄的判定"></a>4.动态对象年龄的判定</h2><p>1.为了更好的适应不同程序的内存状况，对象年龄不是必须到达阈值才会进入老年代2.当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，或年龄大于等于该年龄的对象就可以直接进入老年代  </p>
<h2 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5.空间分配担保"></a>5.空间分配担保</h2><p>1.在发生Minor GC之前，虚拟机会首先检查老年代可用最大内存空间是否大于新生代对象总空间—若大于，则会进行一次安全的Minor GC2.若上述条件不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若不允许，则进行一次FULL GC3.若允许担保失败，则虚拟机会检查老年代最大可用的连续空间是否大于历次晋升到老年代的对象的平均大小，若大于，则进行一次冒险的Minor GC，否则进行一次FULL GC4.若担保失败，还是会进行一次FULL GC。之所以要冒险的原因是为了避免频繁的FULL GC  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/android-viewbus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/android-viewbus/" itemprop="url">View事件分发机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T10:00:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="事件分发机制学习笔记"><a href="#事件分发机制学习笔记" class="headerlink" title="事件分发机制学习笔记"></a>事件分发机制学习笔记</h1><p>通过问题来学习一个东西是很好的方法。学习Android中View的事件体系，我也通过给自己提问题，在解决问题的同时也就知道了其中原理。  </p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>首先来几个问题起步：</p>
<ul>
<li>什么是事件？</li>
<li>什么是事件分发机制？  </li>
</ul>
<p>在我们通过屏幕与手机交互的时候，每一次点击、长按、移动等都是一个个事件。按照面向对象的思想，这些一个个事件都被封装成了MotionEvent。<br>分发机制就是某一个事件从屏幕传递给app视图中的各个View，然后由其中的某个View来使用这一事件或者忽略这一事件，这整个过程的控制就是分发机制了。<br>要注意的是，事件分发机制中，事件是按一个事件序列的形式分发给View的。这一序列由 ACTION_DOWN 开始，经过一系列 ACTION_MOVE 等事件，最后以 ACTION_UP 事件结束。这一个序列中的所有事件，要么被忽略，要么就只能有一个事件能使用。要是同一个序列，比如从按下到移动这一系列的动作，不同的View都能接受的话，那整个界面就会非常混乱，而且逻辑很复杂。<br>接下来我提出这三个问题：</p>
<ul>
<li>某一个事件从屏幕一直传递到View上这一过程的大致流程是怎样的？</li>
<li>前面说了事件分发的其实是事件序列。那么同一个序列里那么多事件，是怎样的机制只交给一个View的？</li>
<li>我们平时在应用开发时，在外部给View设置的的OnClick OnLongClick 的监听，是在哪里被View处理的？</li>
</ul>
<h2 id="问题一：事件传递的流程是怎样的？"><a href="#问题一：事件传递的流程是怎样的？" class="headerlink" title="问题一：事件传递的流程是怎样的？"></a>问题一：事件传递的流程是怎样的？</h2><p>Android中的View是树状结构，如下图所示：  </p>
<p><img src="/img/viewbus/img_view.jpg" alt=""></p>
<p>每一个Activity内部都包含一个Window用来管理要显示的视图。而Window是一个抽象类，其具体实现是 PhoneWindow类。DecovrView作为PhoneWindow的一个内部类，实际管理着具体视图的显示。他是FrameLayout的子类，盛放着我们的标题栏和根视图。我们自己写的一些列View和ViewGroup都是由他来管理的。因此事件分发的时候，顶层的这些“大View”们实际上是不会对事件有任何操作的，他们只是把事件不断的向下递交，直到我们可以使用这些事件。  </p>
<p>所以，事件自顶向下的传递过程应该是这样的：    </p>
<p>Activity（不处理）-&gt; 根View -&gt; 一层一层ViewGroup（如果有的话） -&gt; 子View  </p>
<p>如果传递到最后我们的子View们没有处理这一事件怎么办呢？这时候就会原路返回，最终传递给Activity。只有当Activity也没有处理这一事件时，这一事件才会被丢弃。  </p>
<p>Activity（不处理则丢弃） &lt;- 根View &lt;- 一层一层ViewGroup（如果有的话） &lt;- 子View  </p>
<p>具体在传递事件的时候，是由以下三个方法来控制的：  </p>
<ul>
<li>dispatchTouchEvent : 分发事件  </li>
<li>onInterceptTouchEvent : 拦截事件  </li>
<li>onTouchEvent : 消费事件  </li>
</ul>
<p>这三个方法有一个共同点，就是他们具体是否执行了自己的功能（分发、拦截、消费）完全由自己的返回值来确定，返回true就表示自己完成了自己的功能（分发、拦截、消费）。不同之处除了功能外，还有使用的场景。dispatchTouchEvent()和onTouchEvent()这两个方法，无论是Activity ViewGroup 还是View,都会被用到。而onInterceptTouchEvent()方法因为只是为了拦截事件，那么Activity和View一个在最顶层，一个在最底层，也就没必要使用了。因此在View 和 Activity中是没有onInterceptTouchEvent()方法的。    </p>
<p>我这里自定义几个ViewGroup和View，分别重写他们的这些方法，在重写的时候打上log。在不添加任何监听（即没有View消费事件）的条件下看一下运行结果：</p>
<p>点击外部ViewGroup:<br><img src="/img/viewbus/img_log_1.jpg" alt=""><br>点击子View:<br><img src="/img/viewbus/img_log_2.jpg" alt="">  </p>
<p>可以看到，事件分发首先由ViewGroup的dispatchTouchEvent()方法开始，先调用自己的onInterceptTouchEvent()方法判断是否拦截，返回false表示自己没有拦截，那么接下来直接把事件传给子View。子View调用自己的dispatchTouchEvent()方法进行分发，因为View没有onInterceptTouchEvent()方法，所以不存在拦截操作，因此直接将事件交给自己的onTouchEvent()方法消费。因为我的子View没有使用这个事件，因此onTouchEvent()方法直接返回了false表示自己没有消费，那么这个事件此时就算是传到底了。因为自己没有消费，因此自己就没有分发出去，那么子View的dispatchTouchEvent()方法返回false，把这个事件交还给上一层的ViewGroup。ViewGroup发现这个事件没有子View消费，那么就自己动手吧！将事件传给自己的onTouchEvent()方法消费。可是ViewGroup也没有消费，那么onTouchEvent()方法只能是再返回false了。同理，ViewGroup自己没有消费事件，因此他的dispatchTouchEvent()方法也返回了false。这段文字说得可能有点乱，那么就贴一张图来演示一下：(图中红色箭头表示事件自顶向下分发的过程，黄色则表示自底向上返回的过程)    </p>
<p><img src="/img/viewbus/img_flow_1.jpg" alt="">  </p>
<p>接下来，我在子View上添加OnClick监听，再看一下点击子View时的运行结果：  </p>
<p><img src="/img/viewbus/img_log_3.jpg" alt=""><br>乍一看，呀，怎么重复打印了两遍log?其实并不是哪里写错了。前面我说了，事件分发分发的是一个事件序列，我添加了点击事件，那么我就要消费点击事件。而点击事件其实是要分成两个事件的，即ACTION_DOWN + ACTION_UP ,只有这样才算是一次点击事件。因此打印了“两遍”log其实是先打印了ACTION_DOWN的分发流程，再打印了一遍ACTION_UP的分发流程，因此会看到最后一行打印了click事件。即，click事件是在ACTION_UP事件发生后才发生的。<br>然后看看各个方法的返回值。果然由于我的子View明确表示要消费这个事件序列，因此从ACTION_DOWN开始的所有事件就都交给他消费了。所以子View的onTouchEvent的返回值为true，表示自己需要消费这个事件，然后他的dispatchTouchEvent也返回了true，表示这一事件被自己分发了。既然自己的子View消费了事件，ViewGroup就认为这一事件是被自己分发了，因此他的dispatchTouchEvent也就返回了true。还是来一张图更清楚一点：   </p>
<p><img src="/img/viewbus/img_flow_2.jpg" alt="">   </p>
<p>最后，我在上一步的基础上，给ViewGroup的onInterceptTouchEvent()方法返回值强行改为true，表示事件传到这一层的时候就被拦截了，看一下log:  </p>
<p><img src="/img/viewbus/img_log_4.jpg" alt="">  </p>
<p>果然，虽然我要在子View消费事件，但是事件在传到子View之前就被ViewGroup拦截了，那么事件就只会由ViewGroup来消费了，所以ViewGroup就把事件传给了自己的onTouchEvent()来消费。再来一张图：  </p>
<p><img src="/img/viewbus/img_flow_3.jpg" alt="">  </p>
<p>综上，事件分发的大致流程就是这样。</p>
<h2 id="问题二：如何保证统一序列的事件都交给一个View来处理"><a href="#问题二：如何保证统一序列的事件都交给一个View来处理" class="headerlink" title="问题二：如何保证统一序列的事件都交给一个View来处理"></a>问题二：如何保证统一序列的事件都交给一个View来处理</h2><p>先上结论：在传递过程中，只要有一个View主动去消费了第一个事件（ACTION_DOWN），那么ViewGroup会将这个View保存起来，之后同一事件序列的其他事件都直接交给这个View来处理。具体怎么操作，需要看一下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是ViewGroup  dispatchTouchEvent()的源码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略前面一部分无关代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//handled是返回的结果，表示是否被分发，默认当然是</span></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断一下是不是ACTION_DOWN，如果是的话，代表一个新的事件序列来临了</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">//要注意一下这两个方法，在这里会做一下相当于是“清零”的操作</span></span><br><span class="line">                <span class="comment">//在这里包含了诸如mFirstTouchTarget=null这样的初始化操作</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// intercepted是用来记录是否被拦截的结果</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有mFirstTouchTarget，同时事件为非ACTION_DOWN，那么就算要在这里拦截了</span></span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//忽略部分拦截相关的代码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这两个对象记一下，后面会碰到</span></span><br><span class="line">            TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">              <span class="comment">// 这里就开始对事件类型区分了，如果是ACTION_DOWN，那么就算是一个新的事件序列开始</span></span><br><span class="line">                <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                      <span class="comment">// 准备一下，接下来开始遍历自己的子View们</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取到点击的坐标，用来从子View中筛选出点击到的VIEW</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 按从后向前的顺序开始遍历子View们</span></span><br><span class="line">                        <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                    childrenCount, i, customOrder);</span><br><span class="line">                            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                    preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 其实筛选只是将不合适的View们过滤掉</span></span><br><span class="line">                            <span class="comment">//一个一个continue就表示在发现View不合适的时候直接进入下一次循环</span></span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//终于找到了合适的子View,注意这里将子View封装为一个target</span></span><br><span class="line">                            <span class="comment">//要是返回的结果不为空就跳出循环</span></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                                <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//就算返回结果为空也没关系，在这里继续递归的调用子View的dispatchTransformedTouchEvent()</span></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                                <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//没有找到要接受事件的View</span></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                        <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来就是对于非ACTION_DOWN事件的分发了，这里有两种情况</span></span><br><span class="line">            <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.压根就没有找到要接受事件的view，或者被拦截了，调用了自身的dispatchTransformedTouchEvent()且穿了一个null的View进去，这样有什么用呢？需要后面分析dispatchTransformedTouchEvent()</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//2.有View接受ACTION_DOWN事件，那么这个View也将接受其余的事件</span></span><br><span class="line">                TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">                TouchTarget target = mFirstTouchTarget;</span><br><span class="line">                <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                        <span class="comment">//alreadyDispatchedToNewTouchTarget这个变量在前面View接受ACTION_DOWN事件时设为了true</span></span><br><span class="line">                        <span class="comment">//同时这个mFirstTouchTarget也就是那个View封装好的target</span></span><br><span class="line">                        <span class="comment">//那么这个返回值handled就为true</span></span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//对于非ACTION_DOWN事件，依然是递归调用dispatchTransformedTouchEvent</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                            handled = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mFirstTouchTarget = next;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                predecessor.next = next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target = next;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor = target;</span><br><span class="line">                    target = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理ACTION_UP和ACTION_CANCEL</span></span><br><span class="line">            <span class="keyword">if</span> (canceled</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看看dispatchTransformedTouchEvent()的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//前面在分析dispatchTouchEvent()的时候发现有多处调用了这个dispatchTransformedTouchEvent(),而且有的地方传来的第三个参数是null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理ACTION_CANCEL</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略部分代码……</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果传来的参数child为空时，调用自身dispatchTouchEvent()</span></span><br><span class="line">                    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//不为空，那么就调用他的dispatchTouchEvent()</span></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Done.</span></span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是对dispatchTouchEvent()和dispatchTransformedTouchEvent()的分析，看起来有点乱，这里梳理一下：  </p>
<ul>
<li>首先明确一点，事件分发是从ViewGroup的dispatchTouchEvent()开始的  </li>
<li>ViewGroup在遇到一个新的事件序列，即事件ACTION_DOWN时，开始遍历自己的所有子View,找到需要接收到事件的View  </li>
<li>无论是否找到，都会调用dispatchTransformedTouchEvent()方法，区别在于如果找到了,那么在这个方法中传入的是那个View，否则就是null  </li>
<li>dispatchTransformedTouchEvent()方法中第三个参数child为空时，会调用父类的dispatchTouchEvent()方法，否则会调用那个child的dispatchTouchEvent()方法。总而言之，都会去调用View类的dispatchTouchEvent()方法。  </li>
<li>dispatchTransformedTouchEvent()方法是进行具体的事件分发，除了OnClick()等事件外，onTouchEvent()方法就是在这里调用的  </li>
<li>只要找到了要接受事件的View,就会将他封装为一个target,保存起来，后续的其他事件都由他来接受   </li>
</ul>
<h2 id="问题三：OnClick-OnLongClick等对外的监听是在哪里处理的？"><a href="#问题三：OnClick-OnLongClick等对外的监听是在哪里处理的？" class="headerlink" title="问题三：OnClick OnLongClick等对外的监听是在哪里处理的？"></a>问题三：OnClick OnLongClick等对外的监听是在哪里处理的？</h2><p>首先想一想一个很简单的逻辑，OnClick事件是先ACTION_DOWN之后再ACTION_UP,所以必定要在onTouchEvent()处理。同理，OnLongClick是在保持ACTION_DOWN一段时间后发生，因此也要在onTouchEvent()中处理。看看源码，发现果然是在这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下源码均为忽略了不想关部分，只保留了重点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// 处理click</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">// a short period in case this is a scroll.</span></span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理longclick</span></span><br><span class="line">                    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据前面的分析，在View的dispatchTouchEvent()方法中，会对  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只要获取到的ListenerInfo不为空，就说明我们设置了监听，那么就会认为我们想让这个View处理所有事件</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;<span class="comment">//所以会在这里执行onTouch()</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//而如果没有处理，那么再调用onTouchEvent(),直到onTouchEvent()也返回false才会认为该View不消费事件</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在View的dispatchTouchEvent()方法中，会通过查看是否由设置监听器等方法来判断是否要消费事件。onTouchEvent()方法永远会调用，click和longclick都在这里面。而无论内部如何处理，只要返回了true，就会认为消费了这一事件。    </p>
<p>分析就到这了，作为一个小菜鸡，分析过程难免有些错误和疏漏，欢迎在评论区告诉我  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/19/android-ipc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Levent-J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="靖然是你">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/19/android-ipc/" itemprop="url">Android中的IPC机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-19T12:00:00+08:00">
                2017-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Android IPC机制，就是Andorid中的进程间通信机制，基于Linux，用了自己独特的Binder  </p>
</blockquote>
<hr>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC?"></a>什么是IPC?</h3><p>IPC即Inter Process Communication  ，进程间通信机制的缩写。每一个app默认就是一个进程（除非手动指定多开进程），多个进程之间进行通信就是进程间通信</p>
<h3 id="什么情况下要用到IPC"><a href="#什么情况下要用到IPC" class="headerlink" title="什么情况下要用到IPC ?"></a>什么情况下要用到IPC ?</h3><p>当我们的app有多个进程，或者多个app进程之间需要通信时，就要用到</p>
<h3 id="多进程会有什么问题"><a href="#多进程会有什么问题" class="headerlink" title="多进程会有什么问题"></a>多进程会有什么问题</h3><p>常见的问题：静态成员、单例模式失效，线程同步机制失效，Shared{reference可靠性下降，Application多次创建</p>
<h3 id="有哪些进程间通信方式？"><a href="#有哪些进程间通信方式？" class="headerlink" title="有哪些进程间通信方式？"></a>有哪些进程间通信方式？</h3><p>操作系统常用的进程间通信方式有很多，如信号量、共享文件等。在Android中有AIDL  Socket  ContentProvider等，而这些机制的底层都是用了BIinder机制。所以所，Android的IPC机制，就是Binder机制。  </p>
<h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><h3 id="为什么要用Binder机制？"><a href="#为什么要用Binder机制？" class="headerlink" title="为什么要用Binder机制？"></a>为什么要用Binder机制？</h3><p><a href="https://www.zhihu.com/question/39440766" target="_blank" rel="noopener">可以参考这个回答</a></p>
<p>Android系统基于Linux，Binder机制是相较于Linux的管道、消息队列、共享内存、套接字、信号量、信号等方式之下，相对稳定、高性能、安全、架构清晰的方式。</p>
<h3 id="Binder的结构"><a href="#Binder的结构" class="headerlink" title="Binder的结构"></a>Binder的结构</h3><p>Binder结构是一个C/S架构，两个要通信的进程，分别作为客户端和服务器端。其中客户端不能直接对服务器端做任何操作，需要服务器提供一个代理对象，客户端对服务器的操作要先传给这个代理对象，再由代理对象传给服务器，返回结果之后也是先返回给代理，然后由代理对象返回给客户度端。在这期间，需要有BinderDriver来做枢纽，他作为一个桥梁、中介，一方面对接服务器的代理对象，一方面对接实际的服务端。</p>
<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p>AIDL是一种常见的IPC方式，可以自己写个小Demo学习一下。我在学习的过程中遇到的坑不少，比如需要辅以.aidl文件做通信，要注意在客户端和服务器端aidl文件的包名要相同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Levent-J</p>
              <p class="site-description motion-element" itemprop="description">一只Android小菜鸡学习之路</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Levent-J</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
